   1:				
   2:				;**************************************************************
   3:				;*
   4:				;*             C P / M   version   2 . 2
   5:				;*
   6:				;*   Reconstructed from memory image on February 27, 1981
   7:				;*
   8:				;*                by Clark A. Calkins
   9:				;*
  10:				;**************************************************************
  11:				;
  12:				;   Set memory limit here. This is the amount of contigeous
  13:				; ram starting from 0000. CP/M will reside at the end of this space.
  14:				;
  15:     -	002F          	MEM	EQU	47	;for a 62k system (TS802 TEST - WORKS OK).
  16:				;
  17:     -	0003          	IOBYTE	EQU	3	;i/o definition byte.
  18:     -	0004          	TDRIVE	EQU	4	;current drive name and user number.
  19:     -	0005          	ENTRY	EQU	5	;entry point for the cp/m bdos.
  20:     -	005C          	TFCB	EQU	5CH	;default file control block.
  21:     -	0080          	TBUFF	EQU	80H	;i/o buffer and command line storage.
  22:     -	0100          	TBASE	EQU	100H	;transiant program storage area.
  23:				;
  24:				;   Set control character equates.
  25:				;
  26:     -	0003          	CNTRLC	EQU	3	;control-c
  27:     -	0005          	CNTRLE	EQU	05H	;control-e
  28:     -	0008          	BS	EQU	08H	;backspace
  29:     -	0009          	TAB	EQU	09H	;tab
  30:     -	000A          	LF	EQU	0AH	;line feed
  31:     -	000C          	FF	EQU	0CH	;form feed
  32:     -	000D          	CR	EQU	0DH	;carriage return
  33:     -	0010          	CNTRLP	EQU	10H	;control-p
  34:     -	0012          	CNTRLR	EQU	12H	;control-r
  35:     -	0013          	CNTRLS	EQU	13H	;control-s
  36:     -	0015          	CNTRLU	EQU	15H	;control-u
  37:     -	0018          	CNTRLX	EQU	18H	;control-x
  38:     -	001A          	CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
  39:     -	007F          	DEL	EQU	7FH	;rubout
  40:				;
  41:				;   Set origin for CP/M
  42:				;
  43:     -	A000          		ORG	(MEM-7)*1024
  44:				;
  45:    0+10	A000  C35CA3  	CBASE	JMP	COMMAND		;execute command processor (ccp).
  46:   10+10	A003  C358A3  		JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
  47:				
  48:				;
  49:				;   Standard cp/m ccp input buffer. Format is (max length),
  50:				; (actual length), (char #1), (char #2), (char #3), etc.
  51:				;
  52:     -	A006  7F      	INBUFF	DB	127	;length of input buffer.
  53:     -	A007  00      		DB	0	;current length of contents.
  54:     -	A008  20202020		DB	32,32,32,32,32,32
	              2020
  55:     -	A00E  20202020		DB	32,32,32,32,32,32,32,32,32,32
	              20202020
	              2020
  56:     -	A018  436F7079		DB	"Copyright"
	              72696768
	              74
  57:     -	A021  20313937		DB	" 1979 (c) by Digital Research      "
	              39202863
	              29206279
	              20446967
	              6974616C
	              20526573
	              65617263
	              68202020
	              202020
  58:     -	A044  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  59:     -	A050  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  60:     -	A05C  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  61:     -	A068  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  62:     -	A074  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  63:     -	A080  00000000		DB	0,0,0,0,0,0,0,0
	              00000000
  64:     -	A088  08A0    	INPOINT	DW	INBUFF+2;input line pointer
  65:     -	A08A  0000    	NAMEPNT	DW	0	;input line pointer used for error message. Points to
  66:				;			;start of name in error.
  67:				;
  68:				;   Routine to print (A) on the console. All registers used.
  69:				;
  70:   20+5	A08C  5F      	PRINT	MOV	E,A	;setup bdos call.
  71:   25+7	A08D  0E02    		MVI	C,2
  72:   32+10	A08F  C30500  		JMP	ENTRY
  73:				;
  74:				;   Routine to print (A) on the console and to save (BC).
  75:				;
  76:   42+11	A092  C5      	PRINTB	PUSH	B
  77:   53+17	A093  CD8CA0  		CALL	PRINT
  78:   70+10	A096  C1      		POP	B
  79:   80+10	A097  C9      		RET
  80:				;
  81:				;   Routine to send a carriage return, line feed combination
  82:				; to the console.
  83:				;
  84:   90+7	A098  3E0D    	CRLF	MVI	A,CR
  85:   97+17	A09A  CD92A0  		CALL	PRINTB
  86:  114+7	A09D  3E0A    		MVI	A,LF
  87:  121+10	A09F  C392A0  		JMP	PRINTB
  88:				;
  89:				;   Routine to send one space to the console and save (BC).
  90:				;
  91:  131+7	A0A2  3E20    	SPACE	MVI	A,' '
  92:  138+10	A0A4  C392A0  		JMP	PRINTB
  93:				;
  94:				;   Routine to print character string pointed to be (BC) on the
  95:				; console. It must terminate with a null byte.
  96:				;
  97:  148+11	A0A7  C5      	PLINE	PUSH	B
  98:  159+17	A0A8  CD98A0  		CALL	CRLF
  99:  176+10	A0AB  E1      		POP	H
 100:  186+7	A0AC  7E      	PLINE2	MOV	A,M
 101:  193+4	A0AD  B7      		ORA	A
 102:  197+5+6	A0AE  C8      		RZ
 103:  202+5	A0AF  23      		INX	H
 104:  207+11	A0B0  E5      		PUSH	H
 105:  218+17	A0B1  CD8CA0  		CALL	PRINT
 106:  235+10	A0B4  E1      		POP	H
 107:  245+10	A0B5  C3ACA0  		JMP	PLINE2
 108:				;
 109:				;   Routine to reset the disk system.
 110:				;
 111:  255+7	A0B8  0E0D    	RESDSK	MVI	C,13
 112:  262+10	A0BA  C30500  		JMP	ENTRY
 113:				;
 114:				;   Routine to select disk (A).
 115:				;
 116:  272+5	A0BD  5F      	DSKSEL	MOV	E,A
 117:  277+7	A0BE  0E0E    		MVI	C,14
 118:  284+10	A0C0  C30500  		JMP	ENTRY
 119:				;
 120:				;   Routine to call bdos and save the return code. The zero
 121:				; flag is set on a return of 0ffh.
 122:				;
 123:  294+17	A0C3  CD0500  	ENTRY1	CALL	ENTRY
 124:  311+13	A0C6  32EEA7  		STA	RTNCODE	;save return code.
 125:  324+5	A0C9  3C      		INR	A	;set zero if 0ffh returned.
 126:  329+10	A0CA  C9      		RET
 127:				;
 128:				;   Routine to open a file. (DE) must point to the FCB.
 129:				;
 130:  339+7	A0CB  0E0F    	OPEN	MVI	C,15
 131:  346+10	A0CD  C3C3A0  		JMP	ENTRY1
 132:				;
 133:				;   Routine to open file at (FCB).
 134:				;
 135:  356+4	A0D0  AF      	OPENFCB	XRA	A	;clear the record number byte at fcb+32
 136:  360+13	A0D1  32EDA7  		STA	FCB+32
 137:  373+10	A0D4  11CDA7  		LXI	D,FCB
 138:  383+10	A0D7  C3CBA0  		JMP	OPEN
 139:				;
 140:				;   Routine to close a file. (DE) points to FCB.
 141:				;
 142:  393+7	A0DA  0E10    	CLOSE	MVI	C,16
 143:  400+10	A0DC  C3C3A0  		JMP	ENTRY1
 144:				;
 145:				;   Routine to search for the first file with ambigueous name
 146:				; (DE).
 147:				;
 148:  410+7	A0DF  0E11    	SRCHFST	MVI	C,17
 149:  417+10	A0E1  C3C3A0  		JMP	ENTRY1
 150:				;
 151:				;   Search for the next ambigeous file name.
 152:				;
 153:  427+7	A0E4  0E12    	SRCHNXT	MVI	C,18
 154:  434+10	A0E6  C3C3A0  		JMP	ENTRY1
 155:				;
 156:				;   Search for file at (FCB).
 157:				;
 158:  444+10	A0E9  11CDA7  	SRCHFCB	LXI	D,FCB
 159:  454+10	A0EC  C3DFA0  		JMP	SRCHFST
 160:				;
 161:				;   Routine to delete a file pointed to by (DE).
 162:				;
 163:  464+7	A0EF  0E13    	DELETE	MVI	C,19
 164:  471+10	A0F1  C30500  		JMP	ENTRY
 165:				;
 166:				;   Routine to call the bdos and set the zero flag if a zero
 167:				; status is returned.
 168:				;
 169:  481+17	A0F4  CD0500  	ENTRY2	CALL	ENTRY
 170:  498+4	A0F7  B7      		ORA	A	;set zero flag if appropriate.
 171:  502+10	A0F8  C9      		RET
 172:				;
 173:				;   Routine to read the next record from a sequential file.
 174:				; (DE) points to the FCB.
 175:				;
 176:  512+7	A0F9  0E14    	RDREC	MVI	C,20
 177:  519+10	A0FB  C3F4A0  		JMP	ENTRY2
 178:				;
 179:				;   Routine to read file at (FCB).
 180:				;
 181:  529+10	A0FE  11CDA7  	READFCB	LXI	D,FCB
 182:  539+10	A101  C3F9A0  		JMP	RDREC
 183:				;
 184:				;   Routine to write the next record of a sequential file.
 185:				; (DE) points to the FCB.
 186:				;
 187:  549+7	A104  0E15    	WRTREC	MVI	C,21
 188:  556+10	A106  C3F4A0  		JMP	ENTRY2
 189:				;
 190:				;   Routine to create the file pointed to by (DE).
 191:				;
 192:  566+7	A109  0E16    	CREATE	MVI	C,22
 193:  573+10	A10B  C3C3A0  		JMP	ENTRY1
 194:				;
 195:				;   Routine to rename the file pointed to by (DE). Note that
 196:				; the new name starts at (DE+16).
 197:				;
 198:  583+7	A10E  0E17    	RENAM	MVI	C,23
 199:  590+10	A110  C30500  		JMP	ENTRY
 200:				;
 201:				;   Get the current user code.
 202:				;
 203:  600+7	A113  1EFF    	GETUSR	MVI	E,0FFH
 204:				;
 205:				;   Routne to get or set the current user code.
 206:				; If (E) is FF then this is a GET, else it is a SET.
 207:				;
 208:  607+7	A115  0E20    	GETSETUC:MVI	C,32
 209:  614+10	A117  C30500  		JMP	ENTRY
 210:				;
 211:				;   Routine to set the current drive byte at (TDRIVE).
 212:				;
 213:  624+17	A11A  CD13A1  	SETCDRV	CALL	GETUSR	;get user number
 214:  641+4	A11D  87      		ADD	A	;and shift into the upper 4 bits.
 215:  645+4	A11E  87      		ADD	A
 216:  649+4	A11F  87      		ADD	A
 217:  653+4	A120  87      		ADD	A
 218:  657+10	A121  21EFA7  		LXI	H,CDRIVE;now add in the current drive number.
 219:  667+7	A124  B6      		ORA	M
 220:  674+13	A125  320400  		STA	TDRIVE	;and save.
 221:  687+10	A128  C9      		RET
 222:				;
 223:				;   Move currently active drive down to (TDRIVE).
 224:				;
 225:  697+13	A129  3AEFA7  	MOVECD	LDA	CDRIVE
 226:  710+13	A12C  320400  		STA	TDRIVE
 227:  723+10	A12F  C9      		RET
 228:				;
 229:				;   Routine to convert (A) into upper case ascii. Only letters
 230:				; are affected.
 231:				;
 232:  733+7	A130  FE61    	UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
 233:  740+5+6	A132  D8      		RC
 234:  745+7	A133  FE7B    		CPI	'{'
 235:  752+5+6	A135  D0      		RNC
 236:  757+7	A136  E65F    		ANI	5FH	;convert it if found.
 237:  764+10	A138  C9      		RET
 238:				;
 239:				;   Routine to get a line of input. We must check to see if the
 240:				; user is in (BATCH) mode. If so, then read the input from file
 241:				; ($$$.SUB). At the end, reset to console input.
 242:				;
 243:  774+13	A139  3AABA7  	GETINP	LDA	BATCH	;if =0, then use console input.
 244:  787+4	A13C  B7      		ORA	A
 245:  791+10	A13D  CA96A1  		JZ	GETINP1
 246:				;
 247:				;   Use the submit file ($$$.sub) which is prepared by a
 248:				; SUBMIT run. It must be on drive (A) and it will be deleted
 249:				; if and error occures (like eof).
 250:				;
 251:  801+13	A140  3AEFA7  		LDA	CDRIVE	;select drive 0 if need be.
 252:  814+4	A143  B7      		ORA	A
 253:  818+7	A144  3E00    		MVI	A,0	;always use drive A for submit.
 254:  825+11+6	A146  C4BDA0  		CNZ	DSKSEL	;select it if required.
 255:  836+10	A149  11ACA7  		LXI	D,BATCHFCB
 256:  846+17	A14C  CDCBA0  		CALL	OPEN	;look for it.
 257:  863+10	A14F  CA96A1  		JZ	GETINP1	;if not there, use normal input.
 258:  873+13	A152  3ABBA7  		LDA	BATCHFCB+15;get last record number+1.
 259:  886+5	A155  3D      		DCR	A
 260:  891+13	A156  32CCA7  		STA	BATCHFCB+32
 261:  904+10	A159  11ACA7  		LXI	D,BATCHFCB
 262:  914+17	A15C  CDF9A0  		CALL	RDREC	;read last record.
 263:  931+10	A15F  C296A1  		JNZ	GETINP1	;quit on end of file.
 264:				;
 265:				;   Move this record into input buffer.
 266:				;
 267:  941+10	A162  1107A0  		LXI	D,INBUFF+1
 268:  951+10	A165  218000  		LXI	H,TBUFF	;data was read into buffer here.
 269:  961+7	A168  0680    		MVI	B,128	;all 128 characters may be used.
 270:  968+17	A16A  CD42A4  		CALL	HL2DE	;(HL) to (DE), (B) bytes.
 271:  985+10	A16D  21BAA7  		LXI	H,BATCHFCB+14
 272:  995+10	A170  3600    		MVI	M,0	;zero out the 's2' byte.
 273: 1005+5	A172  23      		INX	H	;and decrement the record count.
 274: 1010+10	A173  35      		DCR	M
 275: 1020+10	A174  11ACA7  		LXI	D,BATCHFCB;close the batch file now.
 276: 1030+17	A177  CDDAA0  		CALL	CLOSE
 277: 1047+10	A17A  CA96A1  		JZ	GETINP1	;quit on an error.
 278: 1057+13	A17D  3AEFA7  		LDA	CDRIVE	;re-select previous drive if need be.
 279: 1070+4	A180  B7      		ORA	A
 280: 1074+11+6	A181  C4BDA0  		CNZ	DSKSEL	;don't do needless selects.
 281:				;
 282:				;   Print line just read on console.
 283:				;
 284: 1085+10	A184  2108A0  		LXI	H,INBUFF+2
 285: 1095+17	A187  CDACA0  		CALL	PLINE2
 286: 1112+17	A18A  CDC2A1  		CALL	CHKCON	;check console, quit on a key.
 287: 1129+10	A18D  CAA7A1  		JZ	GETINP2	;jump if no key is pressed.
 288:				;
 289:				;   Terminate the submit job on any keyboard input. Delete this
 290:				; file such that it is not re-started and jump to normal keyboard
 291:				; input section.
 292:				;
 293: 1139+17	A190  CDDDA1  		CALL	DELBATCH;delete the batch file.
 294: 1156+10	A193  C382A3  		JMP	CMMND1	;and restart command input.
 295:				;
 296:				;   Get here for normal keyboard input. Delete the submit file
 297:				; incase there was one.
 298:				;
 299: 1166+17	A196  CDDDA1  	GETINP1	CALL	DELBATCH;delete file ($$$.sub).
 300: 1183+17	A199  CD1AA1  		CALL	SETCDRV	;reset active disk.
 301: 1200+7	A19C  0E0A    		MVI	C,10	;get line from console device.
 302: 1207+10	A19E  1106A0  		LXI	D,INBUFF
 303: 1217+17	A1A1  CD0500  		CALL	ENTRY
 304: 1234+17	A1A4  CD29A1  		CALL	MOVECD	;reset current drive (again).
 305:				;
 306:				;   Convert input line to upper case.
 307:				;
 308: 1251+10	A1A7  2107A0  	GETINP2	LXI	H,INBUFF+1
 309: 1261+7	A1AA  46      		MOV	B,M	;(B)=character counter.
 310: 1268+5	A1AB  23      	GETINP3	INX	H
 311: 1273+5	A1AC  78      		MOV	A,B	;end of the line?
 312: 1278+4	A1AD  B7      		ORA	A
 313: 1282+10	A1AE  CABAA1  		JZ	GETINP4
 314: 1292+7	A1B1  7E      		MOV	A,M	;convert to upper case.
 315: 1299+17	A1B2  CD30A1  		CALL	UPPER
 316: 1316+7	A1B5  77      		MOV	M,A
 317: 1323+5	A1B6  05      		DCR	B	;adjust character count.
 318: 1328+10	A1B7  C3ABA1  		JMP	GETINP3
 319: 1338+7	A1BA  77      	GETINP4	MOV	M,A	;add trailing null.
 320: 1345+10	A1BB  2108A0  		LXI	H,INBUFF+2
 321: 1355+16	A1BE  2288A0  		SHLD	INPOINT	;reset input line pointer.
 322: 1371+10	A1C1  C9      		RET
 323:				;
 324:				;   Routine to check the console for a key pressed. The zero
 325:				; flag is set is none, else the character is returned in (A).
 326:				;
 327: 1381+7	A1C2  0E0B    	CHKCON	MVI	C,11	;check console.
 328: 1388+17	A1C4  CD0500  		CALL	ENTRY
 329: 1405+4	A1C7  B7      		ORA	A
 330: 1409+5+6	A1C8  C8      		RZ		;return if nothing.
 331: 1414+7	A1C9  0E01    		MVI	C,1	;else get character.
 332: 1421+17	A1CB  CD0500  		CALL	ENTRY
 333: 1438+4	A1CE  B7      		ORA	A	;clear zero flag and return.
 334: 1442+10	A1CF  C9      		RET
 335:				;
 336:				;   Routine to get the currently active drive number.
 337:				;
 338: 1452+7	A1D0  0E19    	GETDSK	MVI	C,25
 339: 1459+10	A1D2  C30500  		JMP	ENTRY
 340:				;
 341:				;   Set the stabdard dma address.
 342:				;
 343: 1469+10	A1D5  118000  	STDDMA	LXI	D,TBUFF
 344:				;
 345:				;   Routine to set the dma address to (DE).
 346:				;
 347: 1479+7	A1D8  0E1A    	DMASET	MVI	C,26
 348: 1486+10	A1DA  C30500  		JMP	ENTRY
 349:				;
 350:				;  Delete the batch file created by SUBMIT.
 351:				;
 352: 1496+10	A1DD  21ABA7  	DELBATCH:LXI	H,BATCH	;is batch active?
 353: 1506+7	A1E0  7E      		MOV	A,M
 354: 1513+4	A1E1  B7      		ORA	A
 355: 1517+5+6	A1E2  C8      		RZ
 356: 1522+10	A1E3  3600    		MVI	M,0	;yes, de-activate it.
 357: 1532+4	A1E5  AF      		XRA	A
 358: 1536+17	A1E6  CDBDA0  		CALL	DSKSEL	;select drive 0 for sure.
 359: 1553+10	A1E9  11ACA7  		LXI	D,BATCHFCB;and delete this file.
 360: 1563+17	A1EC  CDEFA0  		CALL	DELETE
 361: 1580+13	A1EF  3AEFA7  		LDA	CDRIVE	;reset current drive.
 362: 1593+10	A1F2  C3BDA0  		JMP	DSKSEL
 363:				;
 364:				;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
 365:				; the same or we halt....
 366:				;
 367: 1603+10	A1F5  1128A3  	VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
 368: 1613+10	A1F8  2100A8  		LXI	H,PATTRN2;ditto, but how could they be different?
 369: 1623+7	A1FB  0606    		MVI	B,6	;6 bytes each.
 370: 1630+7	A1FD  1A      	VERIFY1	LDAX	D
 371: 1637+7	A1FE  BE      		CMP	M
 372: 1644+10	A1FF  C2CFA3  		JNZ	HALT	;jump to halt routine.
 373: 1654+5	A202  13      		INX	D
 374: 1659+5	A203  23      		INX	H
 375: 1664+5	A204  05      		DCR	B
 376: 1669+10	A205  C2FDA1  		JNZ	VERIFY1
 377: 1679+10	A208  C9      		RET
 378:				;
 379:				;   Print back file name with a '?' to indicate a syntax error.
 380:				;
 381: 1689+17	A209  CD98A0  	SYNERR	CALL	CRLF	;end current line.
 382: 1706+16	A20C  2A8AA0  		LHLD	NAMEPNT	;this points to name in error.
 383: 1722+7	A20F  7E      	SYNERR1	MOV	A,M	;print it until a space or null is found.
 384: 1729+7	A210  FE20    		CPI	' '
 385: 1736+10	A212  CA22A2  		JZ	SYNERR2
 386: 1746+4	A215  B7      		ORA	A
 387: 1750+10	A216  CA22A2  		JZ	SYNERR2
 388: 1760+11	A219  E5      		PUSH	H
 389: 1771+17	A21A  CD8CA0  		CALL	PRINT
 390: 1788+10	A21D  E1      		POP	H
 391: 1798+5	A21E  23      		INX	H
 392: 1803+10	A21F  C30FA2  		JMP	SYNERR1
 393: 1813+7	A222  3E3F    	SYNERR2	MVI	A,'?'	;add trailing '?'.
 394: 1820+17	A224  CD8CA0  		CALL	PRINT
 395: 1837+17	A227  CD98A0  		CALL	CRLF
 396: 1854+17	A22A  CDDDA1  		CALL	DELBATCH;delete any batch file.
 397: 1871+10	A22D  C382A3  		JMP	CMMND1	;and restart from console input.
 398:				;
 399:				;   Check character at (DE) for legal command input. Note that the
 400:				; zero flag is set if the character is a delimiter.
 401:				;
 402: 1881+7	A230  1A      	CHECK	LDAX	D
 403: 1888+4	A231  B7      		ORA	A
 404: 1892+5+6	A232  C8      		RZ
 405: 1897+7	A233  FE20    		CPI	' '	;control characters are not legal here.
 406: 1904+10	A235  DA09A2  		JC	SYNERR
 407: 1914+5+6	A238  C8      		RZ		;check for valid delimiter.
 408: 1919+7	A239  FE3D    		CPI	'='
 409: 1926+5+6	A23B  C8      		RZ
 410: 1931+7	A23C  FE5F    		CPI	'_'
 411: 1938+5+6	A23E  C8      		RZ
 412: 1943+7	A23F  FE2E    		CPI	'.'
 413: 1950+5+6	A241  C8      		RZ
 414: 1955+7	A242  FE3A    		CPI	':'
 415: 1962+5+6	A244  C8      		RZ
 416: 1967+7	A245  FE3B    		CPI	';'
 417: 1974+5+6	A247  C8      		RZ
 418: 1979+7	A248  FE3C    		CPI	'<'
 419: 1986+5+6	A24A  C8      		RZ
 420: 1991+7	A24B  FE3E    		CPI	'>'
 421: 1998+5+6	A24D  C8      		RZ
 422: 2003+10	A24E  C9      		RET
 423:				;
 424:				;   Get the next non-blank character from (DE).
 425:				;
 426: 2013+7	A24F  1A      	NONBLANK:LDAX	D
 427: 2020+4	A250  B7      		ORA	A	;string ends with a null.
 428: 2024+5+6	A251  C8      		RZ
 429: 2029+7	A252  FE20    		CPI	' '
 430: 2036+5+6	A254  C0      		RNZ
 431: 2041+5	A255  13      		INX	D
 432: 2046+10	A256  C34FA2  		JMP	NONBLANK
 433:				;
 434:				;   Add (HL)=(HL)+(A)
 435:				;
 436: 2056+4	A259  85      	ADDHL	ADD	L
 437: 2060+5	A25A  6F      		MOV	L,A
 438: 2065+5+6	A25B  D0      		RNC	;take care of any carry.
 439: 2070+5	A25C  24      		INR	H
 440: 2075+10	A25D  C9      		RET
 441:				;
 442:				;   Convert the first name in (FCB).
 443:				;
 444: 2085+7	A25E  3E00    	CONVFST	MVI	A,0
 445:				;
 446:				;   Format a file name (convert * to '?', etc.). On return,
 447:				; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
 448:				; the position within the fcb for the name (either 0 or 16).
 449:				;
 450: 2092+10	A260  21CDA7  	CONVERT	LXI	H,FCB
 451: 2102+17	A263  CD59A2  		CALL	ADDHL
 452: 2119+11	A266  E5      		PUSH	H
 453: 2130+11	A267  E5      		PUSH	H
 454: 2141+4	A268  AF      		XRA	A
 455: 2145+13	A269  32F0A7  		STA	CHGDRV	;initialize drive change flag.
 456: 2158+16	A26C  2A88A0  		LHLD	INPOINT	;set (HL) as pointer into input line.
 457: 2174+4	A26F  EB      		XCHG
 458: 2178+17	A270  CD4FA2  		CALL	NONBLANK;get next non-blank character.
 459: 2195+4	A273  EB      		XCHG
 460: 2199+16	A274  228AA0  		SHLD	NAMEPNT	;save pointer here for any error message.
 461: 2215+4	A277  EB      		XCHG
 462: 2219+10	A278  E1      		POP	H
 463: 2229+7	A279  1A      		LDAX	D	;get first character.
 464: 2236+4	A27A  B7      		ORA	A
 465: 2240+10	A27B  CA89A2  		JZ	CONVRT1
 466: 2250+7	A27E  DE40    		SBI	'A'-1	;might be a drive name, convert to binary.
 467: 2257+5	A280  47      		MOV	B,A	;and save.
 468: 2262+5	A281  13      		INX	D	;check next character for a ':'.
 469: 2267+7	A282  1A      		LDAX	D
 470: 2274+7	A283  FE3A    		CPI	':'
 471: 2281+10	A285  CA90A2  		JZ	CONVRT2
 472: 2291+5	A288  1B      		DCX	D	;nope, move pointer back to the start of the line.
 473: 2296+13	A289  3AEFA7  	CONVRT1	LDA	CDRIVE
 474: 2309+7	A28C  77      		MOV	M,A
 475: 2316+10	A28D  C396A2  		JMP	CONVRT3
 476: 2326+5	A290  78      	CONVRT2	MOV	A,B
 477: 2331+13	A291  32F0A7  		STA	CHGDRV	;set change in drives flag.
 478: 2344+7	A294  70      		MOV	M,B
 479: 2351+5	A295  13      		INX	D
 480:				;
 481:				;   Convert the basic file name.
 482:				;
 483: 2356+7	A296  0608    	CONVRT3	MVI	B,08H
 484: 2363+17	A298  CD30A2  	CONVRT4	CALL	CHECK
 485: 2380+10	A29B  CAB9A2  		JZ	CONVRT8
 486: 2390+5	A29E  23      		INX	H
 487: 2395+7	A29F  FE2A    		CPI	'*'	;note that an '*' will fill the remaining
 488: 2402+10	A2A1  C2A9A2  		JNZ	CONVRT5	;field with '?'.
 489: 2412+10	A2A4  363F    		MVI	M,'?'
 490: 2422+10	A2A6  C3ABA2  		JMP	CONVRT6
 491: 2432+7	A2A9  77      	CONVRT5	MOV	M,A
 492: 2439+5	A2AA  13      		INX	D
 493: 2444+5	A2AB  05      	CONVRT6	DCR	B
 494: 2449+10	A2AC  C298A2  		JNZ	CONVRT4
 495: 2459+17	A2AF  CD30A2  	CONVRT7	CALL	CHECK	;get next delimiter.
 496: 2476+10	A2B2  CAC0A2  		JZ	GETEXT
 497: 2486+5	A2B5  13      		INX	D
 498: 2491+10	A2B6  C3AFA2  		JMP	CONVRT7
 499: 2501+5	A2B9  23      	CONVRT8	INX	H	;blank fill the file name.
 500: 2506+10	A2BA  3620    		MVI	M,' '
 501: 2516+5	A2BC  05      		DCR	B
 502: 2521+10	A2BD  C2B9A2  		JNZ	CONVRT8
 503:				;
 504:				;   Get the extension and convert it.
 505:				;
 506: 2531+7	A2C0  0603    	GETEXT	MVI	B,03H
 507: 2538+7	A2C2  FE2E    		CPI	'.'
 508: 2545+10	A2C4  C2E9A2  		JNZ	GETEXT5
 509: 2555+5	A2C7  13      		INX	D
 510: 2560+17	A2C8  CD30A2  	GETEXT1	CALL	CHECK
 511: 2577+10	A2CB  CAE9A2  		JZ	GETEXT5
 512: 2587+5	A2CE  23      		INX	H
 513: 2592+7	A2CF  FE2A    		CPI	'*'
 514: 2599+10	A2D1  C2D9A2  		JNZ	GETEXT2
 515: 2609+10	A2D4  363F    		MVI	M,'?'
 516: 2619+10	A2D6  C3DBA2  		JMP	GETEXT3
 517: 2629+7	A2D9  77      	GETEXT2	MOV	M,A
 518: 2636+5	A2DA  13      		INX	D
 519: 2641+5	A2DB  05      	GETEXT3	DCR	B
 520: 2646+10	A2DC  C2C8A2  		JNZ	GETEXT1
 521: 2656+17	A2DF  CD30A2  	GETEXT4	CALL	CHECK
 522: 2673+10	A2E2  CAF0A2  		JZ	GETEXT6
 523: 2683+5	A2E5  13      		INX	D
 524: 2688+10	A2E6  C3DFA2  		JMP	GETEXT4
 525: 2698+5	A2E9  23      	GETEXT5	INX	H
 526: 2703+10	A2EA  3620    		MVI	M,' '
 527: 2713+5	A2EC  05      		DCR	B
 528: 2718+10	A2ED  C2E9A2  		JNZ	GETEXT5
 529: 2728+7	A2F0  0603    	GETEXT6	MVI	B,3
 530: 2735+5	A2F2  23      	GETEXT7	INX	H
 531: 2740+10	A2F3  3600    		MVI	M,0
 532: 2750+5	A2F5  05      		DCR	B
 533: 2755+10	A2F6  C2F2A2  		JNZ	GETEXT7
 534: 2765+4	A2F9  EB      		XCHG
 535: 2769+16	A2FA  2288A0  		SHLD	INPOINT	;save input line pointer.
 536: 2785+10	A2FD  E1      		POP	H
 537:				;
 538:				;   Check to see if this is an ambigeous file name specification.
 539:				; Set the (A) register to non zero if it is.
 540:				;
 541: 2795+10	A2FE  010B00  		LXI	B,11	;set name length.
 542: 2805+5	A301  23      	GETEXT8	INX	H
 543: 2810+7	A302  7E      		MOV	A,M
 544: 2817+7	A303  FE3F    		CPI	'?'	;any question marks?
 545: 2824+10	A305  C209A3  		JNZ	GETEXT9
 546: 2834+5	A308  04      		INR	B	;count them.
 547: 2839+5	A309  0D      	GETEXT9	DCR	C
 548: 2844+10	A30A  C201A3  		JNZ	GETEXT8
 549: 2854+5	A30D  78      		MOV	A,B
 550: 2859+4	A30E  B7      		ORA	A
 551: 2863+10	A30F  C9      		RET
 552:				;
 553:				;   CP/M command table. Note commands can be either 3 or 4 characters long.
 554:				;
 555:     -	0006          	NUMCMDS	EQU	6	;number of commands
 556:     -	A310  44495220	CMDTBL	DB	"DIR "
 557:     -	A314  45524120		DB	"ERA "
 558:     -	A318  54595045		DB	"TYPE"
 559:     -	A31C  53415645		DB	"SAVE"
 560:     -	A320  52454E20		DB	"REN "
 561:     -	A324  55534552		DB	"USER"
 562:				
 563:				;   The following six bytes must agree with those at (PATTRN2)
 564:				; or cp/m will HALT. Why?
 565:				;
 566:     -	A328  00160000	PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
	              0000
 567:				;
 568:				;   Search the command table for a match with what has just
 569:				; been entered. If a match is found, then we jump to the
 570:				; proper section. Else jump to (UNKNOWN).
 571:				; On return, the (C) register is set to the command number
 572:				; that matched (or NUMCMDS+1 if no match).
 573:				;
 574: 2873+10	A32E  2110A3  	SEARCH	LXI	H,CMDTBL
 575: 2883+7	A331  0E00    		MVI	C,0
 576: 2890+5	A333  79      	SEARCH1	MOV	A,C
 577: 2895+7	A334  FE06    		CPI	NUMCMDS	;this commands exists.
 578: 2902+5+6	A336  D0      		RNC
 579: 2907+10	A337  11CEA7  		LXI	D,FCB+1	;check this one.
 580: 2917+7	A33A  0604    		MVI	B,4	;max command length.
 581: 2924+7	A33C  1A      	SEARCH2	LDAX	D
 582: 2931+7	A33D  BE      		CMP	M
 583: 2938+10	A33E  C24FA3  		JNZ	SEARCH3	;not a match.
 584: 2948+5	A341  13      		INX	D
 585: 2953+5	A342  23      		INX	H
 586: 2958+5	A343  05      		DCR	B
 587: 2963+10	A344  C23CA3  		JNZ	SEARCH2
 588: 2973+7	A347  1A      		LDAX	D	;allow a 3 character command to match.
 589: 2980+7	A348  FE20    		CPI	' '
 590: 2987+10	A34A  C254A3  		JNZ	SEARCH4
 591: 2997+5	A34D  79      		MOV	A,C	;set return register for this command.
 592: 3002+10	A34E  C9      		RET
 593: 3012+5	A34F  23      	SEARCH3	INX	H
 594: 3017+5	A350  05      		DCR	B
 595: 3022+10	A351  C24FA3  		JNZ	SEARCH3
 596: 3032+5	A354  0C      	SEARCH4	INR	C
 597: 3037+10	A355  C333A3  		JMP	SEARCH1
 598:				;
 599:				;   Set the input buffer to empty and then start the command
 600:				; processor (ccp).
 601:				;
 602: 3047+4	A358  AF      	CLEARBUF:XRA	A
 603: 3051+13	A359  3207A0  		STA	INBUFF+1;second byte is actual length.
 604:				;
 605:				;**************************************************************
 606:				;*
 607:				;*
 608:				;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
 609:				;*
 610:				;**************************************************************
 611:				;*
 612: 3064+10	A35C  31ABA7  	COMMAND	LXI	SP,CCPSTACK;setup stack area.
 613: 3074+11	A35F  C5      		PUSH	B	;note that (C) should be equal to:
 614: 3085+5	A360  79      		MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
 615: 3090+4	A361  1F      		RAR		;and 'dddd' is the drive number.
 616: 3094+4	A362  1F      		RAR
 617: 3098+4	A363  1F      		RAR
 618: 3102+4	A364  1F      		RAR
 619: 3106+7	A365  E60F    		ANI	0FH	;isolate the user number.
 620: 3113+5	A367  5F      		MOV	E,A
 621: 3118+17	A368  CD15A1  		CALL	GETSETUC;and set it.
 622: 3135+17	A36B  CDB8A0  		CALL	RESDSK	;reset the disk system.
 623: 3152+13	A36E  32ABA7  		STA	BATCH	;clear batch mode flag.
 624: 3165+10	A371  C1      		POP	B
 625: 3175+5	A372  79      		MOV	A,C
 626: 3180+7	A373  E60F    		ANI	0FH	;isolate the drive number.
 627: 3187+13	A375  32EFA7  		STA	CDRIVE	;and save.
 628: 3200+17	A378  CDBDA0  		CALL	DSKSEL	;...and select.
 629: 3217+13	A37B  3A07A0  		LDA	INBUFF+1
 630: 3230+4	A37E  B7      		ORA	A	;anything in input buffer already?
 631: 3234+10	A37F  C298A3  		JNZ	CMMND2	;yes, we just process it.
 632:				;
 633:				;   Entry point to get a command line from the console.
 634:				;
 635: 3244+10	A382  31ABA7  	CMMND1	LXI	SP,CCPSTACK;set stack straight.
 636: 3254+17	A385  CD98A0  		CALL	CRLF	;start a new line on the screen.
 637: 3271+17	A388  CDD0A1  		CALL	GETDSK	;get current drive.
 638: 3288+7	A38B  C661    		ADI	'a'
 639: 3295+17	A38D  CD8CA0  		CALL	PRINT	;print current drive.
 640: 3312+7	A390  3E3E    		MVI	A,'>'
 641: 3319+17	A392  CD8CA0  		CALL	PRINT	;and add prompt.
 642: 3336+17	A395  CD39A1  		CALL	GETINP	;get line from user.
 643:				;
 644:				;   Process command line here.
 645:				;
 646: 3353+10	A398  118000  	CMMND2	LXI	D,TBUFF
 647: 3363+17	A39B  CDD8A1  		CALL	DMASET	;set standard dma address.
 648: 3380+17	A39E  CDD0A1  		CALL	GETDSK
 649: 3397+13	A3A1  32EFA7  		STA	CDRIVE	;set current drive.
 650: 3410+17	A3A4  CD5EA2  		CALL	CONVFST	;convert name typed in.
 651: 3427+11+6	A3A7  C409A2  		CNZ	SYNERR	;wild cards are not allowed.
 652: 3438+13	A3AA  3AF0A7  		LDA	CHGDRV	;if a change in drives was indicated,
 653: 3451+4	A3AD  B7      		ORA	A	;then treat this as an unknown command
 654: 3455+10	A3AE  C2A5A6  		JNZ	UNKNOWN	;which gets executed.
 655: 3465+17	A3B1  CD2EA3  		CALL	SEARCH	;else search command table for a match.
 656:				;
 657:				;   Note that an unknown command returns
 658:				; with (A) pointing to the last address
 659:				; in our table which is (UNKNOWN).
 660:				;
 661: 3482+10	A3B4  21C1A3  		LXI	H,CMDADR;now, look thru our address table for command (A).
 662: 3492+5	A3B7  5F      		MOV	E,A	;set (DE) to command number.
 663: 3497+7	A3B8  1600    		MVI	D,0
 664: 3504+10	A3BA  19      		DAD	D
 665: 3514+10	A3BB  19      		DAD	D	;(HL)=(CMDADR)+2*(command number).
 666: 3524+7	A3BC  7E      		MOV	A,M	;now pick out this address.
 667: 3531+5	A3BD  23      		INX	H
 668: 3536+7	A3BE  66      		MOV	H,M
 669: 3543+5	A3BF  6F      		MOV	L,A
 670: 3548+5	A3C0  E9      		PCHL		;now execute it.
 671:				;
 672:				;   CP/M command address table.
 673:				;
 674:     -	A3C1  77A41FA5	CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
	              5DA5ADA5
 675:     -	A3C9  10A68EA6		DW	RENAME,USER,UNKNOWN
	              A5A6
 676:				;
 677:				;   Halt the system. Reason for this is unknown at present.
 678:				;
 679: 3553+10	A3CF  21F376  	HALT	LXI	H,76F3H	;'DI HLT' instructions.
 680: 3563+16	A3D2  2200A0  		SHLD	CBASE
 681: 3579+10	A3D5  2100A0  		LXI	H,CBASE
 682: 3589+5	A3D8  E9      		PCHL
 683:				;
 684:				;   Read error while TYPEing a file.
 685:				;
 686: 3594+10	A3D9  01DFA3  	RDERROR	LXI	B,RDERR
 687: 3604+10	A3DC  C3A7A0  		JMP	PLINE
 688:     -	A3DF  52656164	RDERR	DB	"Read error",0
	              20657272
	              6F7200
 689:				;
 690:				;   Required file was not located.
 691:				;
 692: 3614+10	A3EA  01F0A3  	NONE	LXI	B,NOFILE
 693: 3624+10	A3ED  C3A7A0  		JMP	PLINE
 694:     -	A3F0  4E6F2066	NOFILE	DB	"No file",0
	              696C6500
 695:				;
 696:				;   Decode a command of the form 'A>filename number{ filename}.
 697:				; Note that a drive specifier is not allowed on the first file
 698:				; name. On return, the number is in register (A). Any error
 699:				; causes 'filename?' to be printed and the command is aborted.
 700:				;
 701: 3634+17	A3F8  CD5EA2  	DECODE	CALL	CONVFST	;convert filename.
 702: 3651+13	A3FB  3AF0A7  		LDA	CHGDRV	;do not allow a drive to be specified.
 703: 3664+4	A3FE  B7      		ORA	A
 704: 3668+10	A3FF  C209A2  		JNZ	SYNERR
 705: 3678+10	A402  21CEA7  		LXI	H,FCB+1	;convert number now.
 706: 3688+10	A405  010B00  		LXI	B,11	;(B)=sum register, (C)=max digit count.
 707: 3698+7	A408  7E      	DECODE1	MOV	A,M
 708: 3705+7	A409  FE20    		CPI	' '	;a space terminates the numeral.
 709: 3712+10	A40B  CA33A4  		JZ	DECODE3
 710: 3722+5	A40E  23      		INX	H
 711: 3727+7	A40F  D630    		SUI	'0'	;make binary from ascii.
 712: 3734+7	A411  FE0A    		CPI	10	;legal digit?
 713: 3741+10	A413  D209A2  		JNC	SYNERR
 714: 3751+5	A416  57      		MOV	D,A	;yes, save it in (D).
 715: 3756+5	A417  78      		MOV	A,B	;compute (B)=(B)*10 and check for overflow.
 716: 3761+7	A418  E6E0    		ANI	0E0H
 717: 3768+10	A41A  C209A2  		JNZ	SYNERR
 718: 3778+5	A41D  78      		MOV	A,B
 719: 3783+4	A41E  07      		RLC
 720: 3787+4	A41F  07      		RLC
 721: 3791+4	A420  07      		RLC	;(A)=(B)*8
 722: 3795+4	A421  80      		ADD	B	;.......*9
 723: 3799+10	A422  DA09A2  		JC	SYNERR
 724: 3809+4	A425  80      		ADD	B	;.......*10
 725: 3813+10	A426  DA09A2  		JC	SYNERR
 726: 3823+4	A429  82      		ADD	D	;add in new digit now.
 727: 3827+10	A42A  DA09A2  	DECODE2	JC	SYNERR
 728: 3837+5	A42D  47      		MOV	B,A	;and save result.
 729: 3842+5	A42E  0D      		DCR	C	;only look at 11 digits.
 730: 3847+10	A42F  C208A4  		JNZ	DECODE1
 731: 3857+10	A432  C9      		RET
 732: 3867+7	A433  7E      	DECODE3	MOV	A,M	;spaces must follow (why?).
 733: 3874+7	A434  FE20    		CPI	' '
 734: 3881+10	A436  C209A2  		JNZ	SYNERR
 735: 3891+5	A439  23      		INX	H
 736: 3896+5	A43A  0D      	DECODE4	DCR	C
 737: 3901+10	A43B  C233A4  		JNZ	DECODE3
 738: 3911+5	A43E  78      		MOV	A,B	;set (A)=the numeric value entered.
 739: 3916+10	A43F  C9      		RET
 740:				;
 741:				;   Move 3 bytes from (HL) to (DE). Note that there is only
 742:				; one reference to this at (A2D5h).
 743:				;
 744: 3926+7	A440  0603    	MOVE3	MVI	B,3
 745:				;
 746:				;   Move (B) bytes from (HL) to (DE).
 747:				;
 748: 3933+7	A442  7E      	HL2DE	MOV	A,M
 749: 3940+7	A443  12      		STAX	D
 750: 3947+5	A444  23      		INX	H
 751: 3952+5	A445  13      		INX	D
 752: 3957+5	A446  05      		DCR	B
 753: 3962+10	A447  C242A4  		JNZ	HL2DE
 754: 3972+10	A44A  C9      		RET
 755:				;
 756:				;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
 757:				;
 758: 3982+10	A44B  218000  	EXTRACT	LXI	H,TBUFF
 759: 3992+4	A44E  81      		ADD	C
 760: 3996+17	A44F  CD59A2  		CALL	ADDHL
 761: 4013+7	A452  7E      		MOV	A,M
 762: 4020+10	A453  C9      		RET
 763:				;
 764:				;  Check drive specified. If it means a change, then the new
 765:				; drive will be selected. In any case, the drive byte of the
 766:				; fcb will be set to null (means use current drive).
 767:				;
 768: 4030+4	A454  AF      	DSELECT	XRA	A	;null out first byte of fcb.
 769: 4034+13	A455  32CDA7  		STA	FCB
 770: 4047+13	A458  3AF0A7  		LDA	CHGDRV	;a drive change indicated?
 771: 4060+4	A45B  B7      		ORA	A
 772: 4064+5+6	A45C  C8      		RZ
 773: 4069+5	A45D  3D      		DCR	A	;yes, is it the same as the current drive?
 774: 4074+10	A45E  21EFA7  		LXI	H,CDRIVE
 775: 4084+7	A461  BE      		CMP	M
 776: 4091+5+6	A462  C8      		RZ
 777: 4096+10	A463  C3BDA0  		JMP	DSKSEL	;no. Select it then.
 778:				;
 779:				;   Check the drive selection and reset it to the previous
 780:				; drive if it was changed for the preceeding command.
 781:				;
 782: 4106+13	A466  3AF0A7  	RESETDR	LDA	CHGDRV	;drive change indicated?
 783: 4119+4	A469  B7      		ORA	A
 784: 4123+5+6	A46A  C8      		RZ
 785: 4128+5	A46B  3D      		DCR	A	;yes, was it a different drive?
 786: 4133+10	A46C  21EFA7  		LXI	H,CDRIVE
 787: 4143+7	A46F  BE      		CMP	M
 788: 4150+5+6	A470  C8      		RZ
 789: 4155+13	A471  3AEFA7  		LDA	CDRIVE	;yes, re-select our old drive.
 790: 4168+10	A474  C3BDA0  		JMP	DSKSEL
 791:				;
 792:				;**************************************************************
 793:				;*
 794:				;*           D I R E C T O R Y   C O M M A N D
 795:				;*
 796:				;**************************************************************
 797:				;
 798: 4178+17	A477  CD5EA2  	DIRECT	CALL	CONVFST	;convert file name.
 799: 4195+17	A47A  CD54A4  		CALL	DSELECT	;select indicated drive.
 800: 4212+10	A47D  21CEA7  		LXI	H,FCB+1	;was any file indicated?
 801: 4222+7	A480  7E      		MOV	A,M
 802: 4229+7	A481  FE20    		CPI	' '
 803: 4236+10	A483  C28FA4  		JNZ	DIRECT2
 804: 4246+7	A486  060B    		MVI	B,11	;no. Fill field with '?' - same as *.*.
 805: 4253+10	A488  363F    	DIRECT1	MVI	M,'?'
 806: 4263+5	A48A  23      		INX	H
 807: 4268+5	A48B  05      		DCR	B
 808: 4273+10	A48C  C288A4  		JNZ	DIRECT1
 809: 4283+7	A48F  1E00    	DIRECT2	MVI	E,0	;set initial cursor position.
 810: 4290+11	A491  D5      		PUSH	D
 811: 4301+17	A492  CDE9A0  		CALL	SRCHFCB	;get first file name.
 812: 4318+11+6	A495  CCEAA3  		CZ	NONE	;none found at all?
 813: 4329+10	A498  CA1BA5  	DIRECT3	JZ	DIRECT9	;terminate if no more names.
 814: 4339+13	A49B  3AEEA7  		LDA	RTNCODE	;get file's position in segment (0-3).
 815: 4352+4	A49E  0F      		RRC
 816: 4356+4	A49F  0F      		RRC
 817: 4360+4	A4A0  0F      		RRC
 818: 4364+7	A4A1  E660    		ANI	60H	;(A)=position*32
 819: 4371+5	A4A3  4F      		MOV	C,A
 820: 4376+7	A4A4  3E0A    		MVI	A,10
 821: 4383+17	A4A6  CD4BA4  		CALL	EXTRACT	;extract the tenth entry in fcb.
 822: 4400+4	A4A9  17      		RAL		;check system file status bit.
 823: 4404+10	A4AA  DA0FA5  		JC	DIRECT8	;we don't list them.
 824: 4414+10	A4AD  D1      		POP	D
 825: 4424+5	A4AE  7B      		MOV	A,E	;bump name count.
 826: 4429+5	A4AF  1C      		INR	E
 827: 4434+11	A4B0  D5      		PUSH	D
 828: 4445+7	A4B1  E603    		ANI	03H	;at end of line?
 829: 4452+11	A4B3  F5      		PUSH	PSW
 830: 4463+10	A4B4  C2CCA4  		JNZ	DIRECT4
 831: 4473+17	A4B7  CD98A0  		CALL	CRLF	;yes, end this line and start another.
 832: 4490+11	A4BA  C5      		PUSH	B
 833: 4501+17	A4BB  CDD0A1  		CALL	GETDSK	;start line with ('A:').
 834: 4518+10	A4BE  C1      		POP	B
 835: 4528+7	A4BF  C641    		ADI	'A'
 836: 4535+17	A4C1  CD92A0  		CALL	PRINTB
 837: 4552+7	A4C4  3E3A    		MVI	A,':'
 838: 4559+17	A4C6  CD92A0  		CALL	PRINTB
 839: 4576+10	A4C9  C3D4A4  		JMP	DIRECT5
 840: 4586+17	A4CC  CDA2A0  	DIRECT4	CALL	SPACE	;add seperator between file names.
 841: 4603+7	A4CF  3E3A    		MVI	A,':'
 842: 4610+17	A4D1  CD92A0  		CALL	PRINTB
 843: 4627+17	A4D4  CDA2A0  	DIRECT5	CALL	SPACE
 844: 4644+7	A4D7  0601    		MVI	B,1	;'extract' each file name character at a time.
 845: 4651+5	A4D9  78      	DIRECT6	MOV	A,B
 846: 4656+17	A4DA  CD4BA4  		CALL	EXTRACT
 847: 4673+7	A4DD  E67F    		ANI	7FH	;strip bit 7 (status bit).
 848: 4680+7	A4DF  FE20    		CPI	' '	;are we at the end of the name?
 849: 4687+10	A4E1  C2F9A4  		JNZ	DRECT65
 850: 4697+10	A4E4  F1      		POP	PSW	;yes, don't print spaces at the end of a line.
 851: 4707+11	A4E5  F5      		PUSH	PSW
 852: 4718+7	A4E6  FE03    		CPI	3
 853: 4725+10	A4E8  C2F7A4  		JNZ	DRECT63
 854: 4735+7	A4EB  3E09    		MVI	A,9	;first check for no extension.
 855: 4742+17	A4ED  CD4BA4  		CALL	EXTRACT
 856: 4759+7	A4F0  E67F    		ANI	7FH
 857: 4766+7	A4F2  FE20    		CPI	' '
 858: 4773+10	A4F4  CA0EA5  		JZ	DIRECT7	;don't print spaces.
 859: 4783+7	A4F7  3E20    	DRECT63	MVI	A,' '	;else print them.
 860: 4790+17	A4F9  CD92A0  	DRECT65	CALL	PRINTB
 861: 4807+5	A4FC  04      		INR	B	;bump to next character psoition.
 862: 4812+5	A4FD  78      		MOV	A,B
 863: 4817+7	A4FE  FE0C    		CPI	12	;end of the name?
 864: 4824+10	A500  D20EA5  		JNC	DIRECT7
 865: 4834+7	A503  FE09    		CPI	9	;nope, starting extension?
 866: 4841+10	A505  C2D9A4  		JNZ	DIRECT6
 867: 4851+17	A508  CDA2A0  		CALL	SPACE	;yes, add seperating space.
 868: 4868+10	A50B  C3D9A4  		JMP	DIRECT6
 869: 4878+10	A50E  F1      	DIRECT7	POP	PSW	;get the next file name.
 870: 4888+17	A50F  CDC2A1  	DIRECT8	CALL	CHKCON	;first check console, quit on anything.
 871: 4905+10	A512  C21BA5  		JNZ	DIRECT9
 872: 4915+17	A515  CDE4A0  		CALL	SRCHNXT	;get next name.
 873: 4932+10	A518  C398A4  		JMP	DIRECT3	;and continue with our list.
 874: 4942+10	A51B  D1      	DIRECT9	POP	D	;restore the stack and return to command level.
 875: 4952+10	A51C  C386A7  		JMP	GETBACK
 876:				;
 877:				;**************************************************************
 878:				;*
 879:				;*                E R A S E   C O M M A N D
 880:				;*
 881:				;**************************************************************
 882:				;
 883: 4962+17	A51F  CD5EA2  	ERASE	CALL	CONVFST	;convert file name.
 884: 4979+7	A522  FE0B    		CPI	11	;was '*.*' entered?
 885: 4986+10	A524  C242A5  		JNZ	ERASE1
 886: 4996+10	A527  0152A5  		LXI	B,YESNO	;yes, ask for confirmation.
 887: 5006+17	A52A  CDA7A0  		CALL	PLINE
 888: 5023+17	A52D  CD39A1  		CALL	GETINP
 889: 5040+10	A530  2107A0  		LXI	H,INBUFF+1
 890: 5050+10	A533  35      		DCR	M	;must be exactly 'y'.
 891: 5060+10	A534  C282A3  		JNZ	CMMND1
 892: 5070+5	A537  23      		INX	H
 893: 5075+7	A538  7E      		MOV	A,M
 894: 5082+7	A539  FE59    		CPI	'Y'
 895: 5089+10	A53B  C282A3  		JNZ	CMMND1
 896: 5099+5	A53E  23      		INX	H
 897: 5104+16	A53F  2288A0  		SHLD	INPOINT	;save input line pointer.
 898: 5120+17	A542  CD54A4  	ERASE1	CALL	DSELECT	;select desired disk.
 899: 5137+10	A545  11CDA7  		LXI	D,FCB
 900: 5147+17	A548  CDEFA0  		CALL	DELETE	;delete the file.
 901: 5164+5	A54B  3C      		INR	A
 902: 5169+11+6	A54C  CCEAA3  		CZ	NONE	;not there?
 903: 5180+10	A54F  C386A7  		JMP	GETBACK	;return to command level now.
 904:     -	A552  416C6C20	YESNO	DB	"All (y/n)?",0
	              28792F6E
	              293F00
 905:				;
 906:				;**************************************************************
 907:				;*
 908:				;*            T Y P E   C O M M A N D
 909:				;*
 910:				;**************************************************************
 911:				;
 912: 5190+17	A55D  CD5EA2  	TYPE	CALL	CONVFST	;convert file name.
 913: 5207+10	A560  C209A2  		JNZ	SYNERR	;wild cards not allowed.
 914: 5217+17	A563  CD54A4  		CALL	DSELECT	;select indicated drive.
 915: 5234+17	A566  CDD0A0  		CALL	OPENFCB	;open the file.
 916: 5251+10	A569  CAA7A5  		JZ	TYPE5	;not there?
 917: 5261+17	A56C  CD98A0  		CALL	CRLF	;ok, start a new line on the screen.
 918: 5278+10	A56F  21F1A7  		LXI	H,NBYTES;initialize byte counter.
 919: 5288+10	A572  36FF    		MVI	M,0FFH	;set to read first sector.
 920: 5298+10	A574  21F1A7  	TYPE1	LXI	H,NBYTES
 921: 5308+7	A577  7E      	TYPE2	MOV	A,M	;have we written the entire sector?
 922: 5315+7	A578  FE80    		CPI	128
 923: 5322+10	A57A  DA87A5  		JC	TYPE3
 924: 5332+11	A57D  E5      		PUSH	H	;yes, read in the next one.
 925: 5343+17	A57E  CDFEA0  		CALL	READFCB
 926: 5360+10	A581  E1      		POP	H
 927: 5370+10	A582  C2A0A5  		JNZ	TYPE4	;end or error?
 928: 5380+4	A585  AF      		XRA	A	;ok, clear byte counter.
 929: 5384+7	A586  77      		MOV	M,A
 930: 5391+10	A587  34      	TYPE3	INR	M	;count this byte.
 931: 5401+10	A588  218000  		LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
 932: 5411+17	A58B  CD59A2  		CALL	ADDHL
 933: 5428+7	A58E  7E      		MOV	A,M
 934: 5435+7	A58F  FE1A    		CPI	CNTRLZ	;end of file mark?
 935: 5442+10	A591  CA86A7  		JZ	GETBACK
 936: 5452+17	A594  CD8CA0  		CALL	PRINT	;no, print it.
 937: 5469+17	A597  CDC2A1  		CALL	CHKCON	;check console, quit if anything ready.
 938: 5486+10	A59A  C286A7  		JNZ	GETBACK
 939: 5496+10	A59D  C374A5  		JMP	TYPE1
 940:				;
 941:				;   Get here on an end of file or read error.
 942:				;
 943: 5506+5	A5A0  3D      	TYPE4	DCR	A	;read error?
 944: 5511+10	A5A1  CA86A7  		JZ	GETBACK
 945: 5521+17	A5A4  CDD9A3  		CALL	RDERROR	;yes, print message.
 946: 5538+17	A5A7  CD66A4  	TYPE5	CALL	RESETDR	;and reset proper drive
 947: 5555+10	A5AA  C309A2  		JMP	SYNERR	;now print file name with problem.
 948:				;
 949:				;**************************************************************
 950:				;*
 951:				;*            S A V E   C O M M A N D
 952:				;*
 953:				;**************************************************************
 954:				;
 955: 5565+17	A5AD  CDF8A3  	SAVE	CALL	DECODE	;get numeric number that follows SAVE.
 956: 5582+11	A5B0  F5      		PUSH	PSW	;save number of pages to write.
 957: 5593+17	A5B1  CD5EA2  		CALL	CONVFST	;convert file name.
 958: 5610+10	A5B4  C209A2  		JNZ	SYNERR	;wild cards not allowed.
 959: 5620+17	A5B7  CD54A4  		CALL	DSELECT	;select specified drive.
 960: 5637+10	A5BA  11CDA7  		LXI	D,FCB	;now delete this file.
 961: 5647+11	A5BD  D5      		PUSH	D
 962: 5658+17	A5BE  CDEFA0  		CALL	DELETE
 963: 5675+10	A5C1  D1      		POP	D
 964: 5685+17	A5C2  CD09A1  		CALL	CREATE	;and create it again.
 965: 5702+10	A5C5  CAFBA5  		JZ	SAVE3	;can't create?
 966: 5712+4	A5C8  AF      		XRA	A	;clear record number byte.
 967: 5716+13	A5C9  32EDA7  		STA	FCB+32
 968: 5729+10	A5CC  F1      		POP	PSW	;convert pages to sectors.
 969: 5739+5	A5CD  6F      		MOV	L,A
 970: 5744+7	A5CE  2600    		MVI	H,0
 971: 5751+10	A5D0  29      		DAD	H	;(HL)=number of sectors to write.
 972: 5761+10	A5D1  110001  		LXI	D,TBASE	;and we start from here.
 973: 5771+5	A5D4  7C      	SAVE1	MOV	A,H	;done yet?
 974: 5776+4	A5D5  B5      		ORA	L
 975: 5780+10	A5D6  CAF1A5  		JZ	SAVE2
 976: 5790+5	A5D9  2B      		DCX	H	;nope, count this and compute the start
 977: 5795+11	A5DA  E5      		PUSH	H	;of the next 128 byte sector.
 978: 5806+10	A5DB  218000  		LXI	H,128
 979: 5816+10	A5DE  19      		DAD	D
 980: 5826+11	A5DF  E5      		PUSH	H	;save it and set the transfer address.
 981: 5837+17	A5E0  CDD8A1  		CALL	DMASET
 982: 5854+10	A5E3  11CDA7  		LXI	D,FCB	;write out this sector now.
 983: 5864+17	A5E6  CD04A1  		CALL	WRTREC
 984: 5881+10	A5E9  D1      		POP	D	;reset (DE) to the start of the last sector.
 985: 5891+10	A5EA  E1      		POP	H	;restore sector count.
 986: 5901+10	A5EB  C2FBA5  		JNZ	SAVE3	;write error?
 987: 5911+10	A5EE  C3D4A5  		JMP	SAVE1
 988:				;
 989:				;   Get here after writing all of the file.
 990:				;
 991: 5921+10	A5F1  11CDA7  	SAVE2	LXI	D,FCB	;now close the file.
 992: 5931+17	A5F4  CDDAA0  		CALL	CLOSE
 993: 5948+5	A5F7  3C      		INR	A	;did it close ok?
 994: 5953+10	A5F8  C201A6  		JNZ	SAVE4
 995:				;
 996:				;   Print out error message (no space).
 997:				;
 998: 5963+10	A5FB  0107A6  	SAVE3	LXI	B,NOSPACE
 999: 5973+17	A5FE  CDA7A0  		CALL	PLINE
1000: 5990+17	A601  CDD5A1  	SAVE4	CALL	STDDMA	;reset the standard dma address.
1001: 6007+10	A604  C386A7  		JMP	GETBACK
1002:     -	A607  4E6F2073	NOSPACE	DB	"No space",0
	              70616365
	              00
1003:				;
1004:				;**************************************************************
1005:				;*
1006:				;*           R E N A M E   C O M M A N D
1007:				;*
1008:				;**************************************************************
1009:				;
1010: 6017+17	A610  CD5EA2  	RENAME	CALL	CONVFST	;convert first file name.
1011: 6034+10	A613  C209A2  		JNZ	SYNERR	;wild cards not allowed.
1012: 6044+13	A616  3AF0A7  		LDA	CHGDRV	;remember any change in drives specified.
1013: 6057+11	A619  F5      		PUSH	PSW
1014: 6068+17	A61A  CD54A4  		CALL	DSELECT	;and select this drive.
1015: 6085+17	A61D  CDE9A0  		CALL	SRCHFCB	;is this file present?
1016: 6102+10	A620  C279A6  		JNZ	RENAME6	;yes, print error message.
1017: 6112+10	A623  21CDA7  		LXI	H,FCB	;yes, move this name into second slot.
1018: 6122+10	A626  11DDA7  		LXI	D,FCB+16
1019: 6132+7	A629  0610    		MVI	B,16
1020: 6139+17	A62B  CD42A4  		CALL	HL2DE
1021: 6156+16	A62E  2A88A0  		LHLD	INPOINT	;get input pointer.
1022: 6172+4	A631  EB      		XCHG
1023: 6176+17	A632  CD4FA2  		CALL	NONBLANK;get next non blank character.
1024: 6193+7	A635  FE3D    		CPI	'='	;only allow an '=' or '_' seperator.
1025: 6200+10	A637  CA3FA6  		JZ	RENAME1
1026: 6210+7	A63A  FE5F    		CPI	'_'
1027: 6217+10	A63C  C273A6  		JNZ	RENAME5
1028: 6227+4	A63F  EB      	RENAME1	XCHG
1029: 6231+5	A640  23      		INX	H	;ok, skip seperator.
1030: 6236+16	A641  2288A0  		SHLD	INPOINT	;save input line pointer.
1031: 6252+17	A644  CD5EA2  		CALL	CONVFST	;convert this second file name now.
1032: 6269+10	A647  C273A6  		JNZ	RENAME5	;again, no wild cards.
1033: 6279+10	A64A  F1      		POP	PSW	;if a drive was specified, then it
1034: 6289+5	A64B  47      		MOV	B,A	;must be the same as before.
1035: 6294+10	A64C  21F0A7  		LXI	H,CHGDRV
1036: 6304+7	A64F  7E      		MOV	A,M
1037: 6311+4	A650  B7      		ORA	A
1038: 6315+10	A651  CA59A6  		JZ	RENAME2
1039: 6325+4	A654  B8      		CMP	B
1040: 6329+7	A655  70      		MOV	M,B
1041: 6336+10	A656  C273A6  		JNZ	RENAME5	;they were different, error.
1042: 6346+7	A659  70      	RENAME2	MOV	M,B;	reset as per the first file specification.
1043: 6353+4	A65A  AF      		XRA	A
1044: 6357+13	A65B  32CDA7  		STA	FCB	;clear the drive byte of the fcb.
1045: 6370+17	A65E  CDE9A0  	RENAME3	CALL	SRCHFCB	;and go look for second file.
1046: 6387+10	A661  CA6DA6  		JZ	RENAME4	;doesn't exist?
1047: 6397+10	A664  11CDA7  		LXI	D,FCB
1048: 6407+17	A667  CD0EA1  		CALL	RENAM	;ok, rename the file.
1049: 6424+10	A66A  C386A7  		JMP	GETBACK
1050:				;
1051:				;   Process rename errors here.
1052:				;
1053: 6434+17	A66D  CDEAA3  	RENAME4	CALL	NONE	;file not there.
1054: 6451+10	A670  C386A7  		JMP	GETBACK
1055: 6461+17	A673  CD66A4  	RENAME5	CALL	RESETDR	;bad command format.
1056: 6478+10	A676  C309A2  		JMP	SYNERR
1057: 6488+10	A679  0182A6  	RENAME6	LXI	B,EXISTS;destination file already exists.
1058: 6498+17	A67C  CDA7A0  		CALL	PLINE
1059: 6515+10	A67F  C386A7  		JMP	GETBACK
1060:     -	A682  46696C65	EXISTS	DB	"File exists",0
	              20657869
	              73747300
1061:				;
1062:				;**************************************************************
1063:				;*
1064:				;*             U S E R   C O M M A N D
1065:				;*
1066:				;**************************************************************
1067:				;
1068: 6525+17	A68E  CDF8A3  	USER	CALL	DECODE	;get numeric value following command.
1069: 6542+7	A691  FE10    		CPI	16	;legal user number?
1070: 6549+10	A693  D209A2  		JNC	SYNERR
1071: 6559+5	A696  5F      		MOV	E,A	;yes but is there anything else?
1072: 6564+13	A697  3ACEA7  		LDA	FCB+1
1073: 6577+7	A69A  FE20    		CPI	' '
1074: 6584+10	A69C  CA09A2  		JZ	SYNERR	;yes, that is not allowed.
1075: 6594+17	A69F  CD15A1  		CALL	GETSETUC;ok, set user code.
1076: 6611+10	A6A2  C389A7  		JMP	GETBACK1
1077:				;
1078:				;**************************************************************
1079:				;*
1080:				;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1081:				;*
1082:				;**************************************************************
1083:				;
1084: 6621+17	A6A5  CDF5A1  	UNKNOWN	CALL	VERIFY	;check for valid system (why?).
1085: 6638+13	A6A8  3ACEA7  		LDA	FCB+1	;anything to execute?
1086: 6651+7	A6AB  FE20    		CPI	' '
1087: 6658+10	A6AD  C2C4A6  		JNZ	UNKWN1
1088: 6668+13	A6B0  3AF0A7  		LDA	CHGDRV	;nope, only a drive change?
1089: 6681+4	A6B3  B7      		ORA	A
1090: 6685+10	A6B4  CA89A7  		JZ	GETBACK1;neither???
1091: 6695+5	A6B7  3D      		DCR	A
1092: 6700+13	A6B8  32EFA7  		STA	CDRIVE	;ok, store new drive.
1093: 6713+17	A6BB  CD29A1  		CALL	MOVECD	;set (TDRIVE) also.
1094: 6730+17	A6BE  CDBDA0  		CALL	DSKSEL	;and select this drive.
1095: 6747+10	A6C1  C389A7  		JMP	GETBACK1;then return.
1096:				;
1097:				;   Here a file name was typed. Prepare to execute it.
1098:				;
1099: 6757+10	A6C4  11D6A7  	UNKWN1	LXI	D,FCB+9	;an extension specified?
1100: 6767+7	A6C7  1A      		LDAX	D
1101: 6774+7	A6C8  FE20    		CPI	' '
1102: 6781+10	A6CA  C209A2  		JNZ	SYNERR	;yes, not allowed.
1103: 6791+11	A6CD  D5      	UNKWN2	PUSH	D
1104: 6802+17	A6CE  CD54A4  		CALL	DSELECT	;select specified drive.
1105: 6819+10	A6D1  D1      		POP	D
1106: 6829+10	A6D2  2183A7  		LXI	H,COMFILE	;set the extension to 'COM'.
1107: 6839+17	A6D5  CD40A4  		CALL	MOVE3
1108: 6856+17	A6D8  CDD0A0  		CALL	OPENFCB	;and open this file.
1109: 6873+10	A6DB  CA6BA7  		JZ	UNKWN9	;not present?
1110:				;
1111:				;   Load in the program.
1112:				;
1113: 6883+10	A6DE  210001  		LXI	H,TBASE	;store the program starting here.
1114: 6893+11	A6E1  E5      	UNKWN3	PUSH	H
1115: 6904+4	A6E2  EB      		XCHG
1116: 6908+17	A6E3  CDD8A1  		CALL	DMASET	;set transfer address.
1117: 6925+10	A6E6  11CDA7  		LXI	D,FCB	;and read the next record.
1118: 6935+17	A6E9  CDF9A0  		CALL	RDREC
1119: 6952+10	A6EC  C201A7  		JNZ	UNKWN4	;end of file or read error?
1120: 6962+10	A6EF  E1      		POP	H	;nope, bump pointer for next sector.
1121: 6972+10	A6F0  118000  		LXI	D,128
1122: 6982+10	A6F3  19      		DAD	D
1123: 6992+10	A6F4  1100A0  		LXI	D,CBASE	;enough room for the whole file?
1124: 7002+5	A6F7  7D      		MOV	A,L
1125: 7007+4	A6F8  93      		SUB	E
1126: 7011+5	A6F9  7C      		MOV	A,H
1127: 7016+4	A6FA  9A      		SBB	D
1128: 7020+10	A6FB  D271A7  		JNC	UNKWN0	;no, it can't fit.
1129: 7030+10	A6FE  C3E1A6  		JMP	UNKWN3
1130:				;
1131:				;   Get here after finished reading.
1132:				;
1133: 7040+10	A701  E1      	UNKWN4	POP	H
1134: 7050+5	A702  3D      		DCR	A	;normal end of file?
1135: 7055+10	A703  C271A7  		JNZ	UNKWN0
1136: 7065+17	A706  CD66A4  		CALL	RESETDR	;yes, reset previous drive.
1137: 7082+17	A709  CD5EA2  		CALL	CONVFST	;convert the first file name that follows
1138: 7099+10	A70C  21F0A7  		LXI	H,CHGDRV;command name.
1139: 7109+11	A70F  E5      		PUSH	H
1140: 7120+7	A710  7E      		MOV	A,M	;set drive code in default fcb.
1141: 7127+13	A711  32CDA7  		STA	FCB
1142: 7140+7	A714  3E10    		MVI	A,16	;put second name 16 bytes later.
1143: 7147+17	A716  CD60A2  		CALL	CONVERT	;convert second file name.
1144: 7164+10	A719  E1      		POP	H
1145: 7174+7	A71A  7E      		MOV	A,M	;and set the drive for this second file.
1146: 7181+13	A71B  32DDA7  		STA	FCB+16
1147: 7194+4	A71E  AF      		XRA	A	;clear record byte in fcb.
1148: 7198+13	A71F  32EDA7  		STA	FCB+32
1149: 7211+10	A722  115C00  		LXI	D,TFCB	;move it into place at(005Ch).
1150: 7221+10	A725  21CDA7  		LXI	H,FCB
1151: 7231+7	A728  0621    		MVI	B,33
1152: 7238+17	A72A  CD42A4  		CALL	HL2DE
1153: 7255+10	A72D  2108A0  		LXI	H,INBUFF+2;now move the remainder of the input
1154: 7265+7	A730  7E      	UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
1155: 7272+4	A731  B7      		ORA	A	;or a null.
1156: 7276+10	A732  CA3EA7  		JZ	UNKWN6
1157: 7286+7	A735  FE20    		CPI	' '
1158: 7293+10	A737  CA3EA7  		JZ	UNKWN6
1159: 7303+5	A73A  23      		INX	H
1160: 7308+10	A73B  C330A7  		JMP	UNKWN5
1161:				;
1162:				;   Do the line move now. It ends in a null byte.
1163:				;
1164: 7318+7	A73E  0600    	UNKWN6	MVI	B,0	;keep a character count.
1165: 7325+10	A740  118100  		LXI	D,TBUFF+1;data gets put here.
1166: 7335+7	A743  7E      	UNKWN7	MOV	A,M	;move it now.
1167: 7342+7	A744  12      		STAX	D
1168: 7349+4	A745  B7      		ORA	A
1169: 7353+10	A746  CA4FA7  		JZ	UNKWN8
1170: 7363+5	A749  04      		INR	B
1171: 7368+5	A74A  23      		INX	H
1172: 7373+5	A74B  13      		INX	D
1173: 7378+10	A74C  C343A7  		JMP	UNKWN7
1174: 7388+5	A74F  78      	UNKWN8	MOV	A,B	;now store the character count.
1175: 7393+13	A750  328000  		STA	TBUFF
1176: 7406+17	A753  CD98A0  		CALL	CRLF	;clean up the screen.
1177: 7423+17	A756  CDD5A1  		CALL	STDDMA	;set standard transfer address.
1178: 7440+17	A759  CD1AA1  		CALL	SETCDRV	;reset current drive.
1179: 7457+17	A75C  CD0001  		CALL	TBASE	;and execute the program.
1180:				;
1181:				;   Transiant programs return here (or reboot).
1182:				;
1183: 7474+10	A75F  31ABA7  		LXI	SP,BATCH	;set stack first off.
1184: 7484+17	A762  CD29A1  		CALL	MOVECD	;move current drive into place (TDRIVE).
1185: 7501+17	A765  CDBDA0  		CALL	DSKSEL	;and reselect it.
1186: 7518+10	A768  C382A3  		JMP	CMMND1	;back to comand mode.
1187:				;
1188:				;   Get here if some error occured.
1189:				;
1190: 7528+17	A76B  CD66A4  	UNKWN9	CALL	RESETDR	;inproper format.
1191: 7545+10	A76E  C309A2  		JMP	SYNERR
1192: 7555+10	A771  017AA7  	UNKWN0	LXI	B,BADLOAD;read error or won't fit.
1193: 7565+17	A774  CDA7A0  		CALL	PLINE
1194: 7582+10	A777  C386A7  		JMP	GETBACK
1195:     -	A77A  42616420	BADLOAD	DB	"Bad load",0
	              6C6F6164
	              00
1196:     -	A783  434F4D  	COMFILE	DB	"COM"	;command file extension.
1197:				;
1198:				;   Get here to return to command level. We will reset the
1199:				; previous active drive and then either return to command
1200:				; level directly or print error message and then return.
1201:				;
1202: 7592+17	A786  CD66A4  	GETBACK	CALL	RESETDR	;reset previous drive.
1203: 7609+17	A789  CD5EA2  	GETBACK1:CALL	CONVFST	;convert first name in (FCB).
1204: 7626+13	A78C  3ACEA7  		LDA	FCB+1	;if this was just a drive change request,
1205: 7639+7	A78F  D620    		SUI	' '	;make sure it was valid.
1206: 7646+10	A791  21F0A7  		LXI	H,CHGDRV
1207: 7656+7	A794  B6      		ORA	M
1208: 7663+10	A795  C209A2  		JNZ	SYNERR
1209: 7673+10	A798  C382A3  		JMP	CMMND1	;ok, return to command level.
1210:				;
1211:				;   ccp stack area.
1212:				;
1213:     -	A79B  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
1214:     -	A7AB          	CCPSTACK:EQU	$	;end of ccp stack area.
1215:				;
1216:				;   Batch (or SUBMIT) processing information storage.
1217:				;
1218:     -	A7AB  00      	BATCH	DB	0	;batch mode flag (0=not active).
1219:     -	A7AC  00242424	BATCHFCB:DB	0,"$$$     SUB"
	              20202020
	              20535542
1220:     -	A7B8  00000000		 DB	0,0,0,0,0,0,0,0,0,0
	              00000000
	              0000
1221:     -	A7C2  00000000		 DB	0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              000000
1222:				;
1223:				;   File control block setup by the CCP.
1224:				;
1225:     -	A7CD  00202020	FCB	DB	0,"           ",0,0,0,0,0,"           ",0,0,0,0,0
	              20202020
	              20202020
	              00000000
	              00202020
	              20202020
	              20202020
	              00000000
	              00
1226:     -	A7EE  00      	RTNCODE	DB	0	;status returned from bdos call.
1227:     -	A7EF  00      	CDRIVE	DB	0	;currently active drive.
1228:     -	A7F0  00      	CHGDRV	DB	0	;change in drives flag (0=no change).
1229:     -	A7F1  0000    	NBYTES	DW	0	;byte counter used by TYPE.
1230:				;
1231:				;   Room for expansion?
1232:				;
1233:     -	A7F3  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00
1234:				;
1235:				;   Note that the following six bytes must match those at
1236:				; (PATTRN1) or cp/m will HALT. Why?
1237:				;
1238:     -	A800  00160000	PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
	              0000
1239:				;
1240:				;**************************************************************
1241:				;*
1242:				;*                    B D O S   E N T R Y
1243:				;*
1244:				;**************************************************************
1245:				;
1246: 7683+10	A806  C311A8  	FBASE	JMP	FBASE1
1247:				;
1248:				;   Bdos error table.
1249:				;
1250:     -	A809  99A8    	BADSCTR	DW	ERROR1	;bad sector on read or write.
1251:     -	A80B  A5A8    	BADSLCT	DW	ERROR2	;bad disk select.
1252:     -	A80D  ABA8    	RODISK	DW	ERROR3	;disk is read only.
1253:     -	A80F  B1A8    	ROFILE	DW	ERROR4	;file is read only.
1254:				;
1255:				;   Entry into bdos. (DE) or (E) are the parameters passed. The
1256:				; function number desired is in register (C).
1257:				;
1258: 7693+4	A811  EB      	FBASE1	XCHG		;save the (DE) parameters.
1259: 7697+16	A812  2243AB  		SHLD	PARAMS
1260: 7713+4	A815  EB      		XCHG
1261: 7717+5	A816  7B      		MOV	A,E	;and save register (E) in particular.
1262: 7722+13	A817  32D6B5  		STA	EPARAM
1263: 7735+10	A81A  210000  		LXI	H,0
1264: 7745+16	A81D  2245AB  		SHLD	STATUS	;clear return status.
1265: 7761+10	A820  39      		DAD	SP
1266: 7771+16	A821  220FAB  		SHLD	USRSTACK;save users stack pointer.
1267: 7787+10	A824  3141AB  		LXI	SP,STKAREA;and set our own.
1268: 7797+4	A827  AF      		XRA	A	;clear auto select storage space.
1269: 7801+13	A828  32E0B5  		STA	AUTOFLAG
1270: 7814+13	A82B  32DEB5  		STA	AUTO
1271: 7827+10	A82E  2174B5  		LXI	H,GOBACK;set return address.
1272: 7837+11	A831  E5      		PUSH	H
1273: 7848+5	A832  79      		MOV	A,C	;get function number.
1274: 7853+7	A833  FE29    		CPI	NFUNCTS	;valid function number?
1275: 7860+5+6	A835  D0      		RNC
1276: 7865+5	A836  4B      		MOV	C,E	;keep single register function here.
1277: 7870+10	A837  2147A8  		LXI	H,FUNCTNS;now look thru the function table.
1278: 7880+5	A83A  5F      		MOV	E,A
1279: 7885+7	A83B  1600    		MVI	D,0	;(DE)=function number.
1280: 7892+10	A83D  19      		DAD	D
1281: 7902+10	A83E  19      		DAD	D	;(HL)=(start of table)+2*(function number).
1282: 7912+7	A83F  5E      		MOV	E,M
1283: 7919+5	A840  23      		INX	H
1284: 7924+7	A841  56      		MOV	D,M	;now (DE)=address for this function.
1285: 7931+16	A842  2A43AB  		LHLD	PARAMS	;retrieve parameters.
1286: 7947+4	A845  EB      		XCHG		;now (DE) has the original parameters.
1287: 7951+5	A846  E9      		PCHL		;execute desired function.
1288:				;
1289:				;   BDOS function jump table.
1290:				;
1291:     -	0029          	NFUNCTS	EQU	41	;number of functions in followin table.
1292:				;
1293:     -	A847  03B6C8AA	FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
	              90A9CEAA
	              12B60FB6
	              D4AAEDAA
1294:     -	A857  F3AAF8AA		DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
	              E1A9FEAA
	              7EB483B4
	              45B49CB4
1295:     -	A867  A5B4ABB4		DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
	              C8B4D7B4
	              E0B4E6B4
	              ECB4
1296:     -	A875  F5B4FEB4		DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
	              04B50AB5
	              11B52CAD
	              17B51DB5
1297:     -	A885  26B52DB5		DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
	              41B547B5
	              4DB50EB4
	              53B504AB
1298:     -	A895  04AB9BB5		DW	RTN,WTSPECL
1299:				;
1300:				;   Bdos error message section.
1301:				;
1302: 7956+10	A899  21CAA8  	ERROR1	LXI	H,BADSEC	;bad sector message.
1303: 7966+17	A89C  CDE5A8  		CALL	PRTERR	;print it and get a 1 char responce.
1304: 7983+7	A89F  FE03    		CPI	CNTRLC	;re-boot request (control-c)?
1305: 7990+10	A8A1  CA0000  		JZ	0	;yes.
1306: 8000+10	A8A4  C9      		RET		;no, return to retry i/o function.
1307:				;
1308: 8010+10	A8A5  21D5A8  	ERROR2	LXI	H,BADSEL	;bad drive selected.
1309: 8020+10	A8A8  C3B4A8  		JMP	ERROR5
1310:				;
1311: 8030+10	A8AB  21E1A8  	ERROR3	LXI	H,DISKRO	;disk is read only.
1312: 8040+10	A8AE  C3B4A8  		JMP	ERROR5
1313:				;
1314: 8050+10	A8B1  21DCA8  	ERROR4	LXI	H,FILERO	;file is read only.
1315:				;
1316: 8060+17	A8B4  CDE5A8  	ERROR5	CALL	PRTERR
1317: 8077+10	A8B7  C30000  		JMP	0	;always reboot on these errors.
1318:				;
1319:     -	A8BA  42646F73	BDOSERR	DB	"Bdos Err On "
	              20457272
	              204F6E20
1320:     -	A8C6  203A2024	BDOSDRV	DB	" : $"
1321:     -	A8CA  42616420	BADSEC	DB	"Bad Sector$"
	              53656374
	              6F7224
1322:     -	A8D5  53656C65	BADSEL	DB	"Select$"
	              637424
1323:     -	A8DC  46696C65	FILERO	DB	"File "
	              20
1324:     -	A8E1  522F4F24	DISKRO	DB	"R/O$"
1325:				;
1326:				;   Print bdos error message.
1327:				;
1328: 8087+11	A8E5  E5      	PRTERR	PUSH	H	;save second message pointer.
1329: 8098+17	A8E6  CDC9A9  		CALL	OUTCRLF	;send (cr)(lf).
1330: 8115+13	A8E9  3A42AB  		LDA	ACTIVE	;get active drive.
1331: 8128+7	A8EC  C641    		ADI	'A'	;make ascii.
1332: 8135+13	A8EE  32C6A8  		STA	BDOSDRV	;and put in message.
1333: 8148+10	A8F1  01BAA8  		LXI	B,BDOSERR;and print it.
1334: 8158+17	A8F4  CDD3A9  		CALL	PRTMESG
1335: 8175+10	A8F7  C1      		POP	B	;print second message line now.
1336: 8185+17	A8F8  CDD3A9  		CALL	PRTMESG
1337:				;
1338:				;   Get an input character. We will check our 1 character
1339:				; buffer first. This may be set by the console status routine.
1340:				;
1341: 8202+10	A8FB  210EAB  	GETCHAR	LXI	H,CHARBUF;check character buffer.
1342: 8212+7	A8FE  7E      		MOV	A,M	;anything present already?
1343: 8219+10	A8FF  3600    		MVI	M,0	;...either case clear it.
1344: 8229+4	A901  B7      		ORA	A
1345: 8233+5+6	A902  C0      		RNZ		;yes, use it.
1346: 8238+10	A903  C309B6  		JMP	CONIN	;nope, go get a character responce.
1347:				;
1348:				;   Input and echo a character.
1349:				;
1350: 8248+17	A906  CDFBA8  	GETECHO	CALL	GETCHAR	;input a character.
1351: 8265+17	A909  CD14A9  		CALL	CHKCHAR	;carriage control?
1352: 8282+5+6	A90C  D8      		RC		;no, a regular control char so don't echo.
1353: 8287+11	A90D  F5      		PUSH	PSW	;ok, save character now.
1354: 8298+5	A90E  4F      		MOV	C,A
1355: 8303+17	A90F  CD90A9  		CALL	OUTCON	;and echo it.
1356: 8320+10	A912  F1      		POP	PSW	;get character and return.
1357: 8330+10	A913  C9      		RET
1358:				;
1359:				;   Check character in (A). Set the zero flag on a carriage
1360:				; control character and the carry flag on any other control
1361:				; character.
1362:				;
1363: 8340+7	A914  FE0D    	CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
1364: 8347+5+6	A916  C8      		RZ		;or a tab.
1365: 8352+7	A917  FE0A    		CPI	LF
1366: 8359+5+6	A919  C8      		RZ
1367: 8364+7	A91A  FE09    		CPI	TAB
1368: 8371+5+6	A91C  C8      		RZ
1369: 8376+7	A91D  FE08    		CPI	BS
1370: 8383+5+6	A91F  C8      		RZ
1371: 8388+7	A920  FE20    		CPI	' '	;other control char? Set carry flag.
1372: 8395+10	A922  C9      		RET
1373:				;
1374:				;   Check the console during output. Halt on a control-s, then
1375:				; reboot on a control-c. If anything else is ready, clear the
1376:				; zero flag and return (the calling routine may want to do
1377:				; something).
1378:				;
1379: 8405+13	A923  3A0EAB  	CKCONSOL:LDA	CHARBUF	;check buffer.
1380: 8418+4	A926  B7      		ORA	A	;if anything, just return without checking.
1381: 8422+10	A927  C245A9  		JNZ	CKCON2
1382: 8432+17	A92A  CD06B6  		CALL	CONST	;nothing in buffer. Check console.
1383: 8449+7	A92D  E601    		ANI	01H	;look at bit 0.
1384: 8456+5+6	A92F  C8      		RZ		;return if nothing.
1385: 8461+17	A930  CD09B6  		CALL	CONIN	;ok, get it.
1386: 8478+7	A933  FE13    		CPI	CNTRLS	;if not control-s, return with zero cleared.
1387: 8485+10	A935  C242A9  		JNZ	CKCON1
1388: 8495+17	A938  CD09B6  		CALL	CONIN	;halt processing until another char
1389: 8512+7	A93B  FE03    		CPI	CNTRLC	;is typed. Control-c?
1390: 8519+10	A93D  CA0000  		JZ	0	;yes, reboot now.
1391: 8529+4	A940  AF      		XRA	A	;no, just pretend nothing was ever ready.
1392: 8533+10	A941  C9      		RET
1393: 8543+13	A942  320EAB  	CKCON1	STA	CHARBUF	;save character in buffer for later processing.
1394: 8556+7	A945  3E01    	CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
1395: 8563+10	A947  C9      		RET
1396:				;
1397:				;   Output (C) to the screen. If the printer flip-flop flag
1398:				; is set, we will send character to printer also. The console
1399:				; will be checked in the process.
1400:				;
1401: 8573+13	A948  3A0AAB  	OUTCHAR	LDA	OUTFLAG	;check output flag.
1402: 8586+4	A94B  B7      		ORA	A	;anything and we won't generate output.
1403: 8590+10	A94C  C262A9  		JNZ	OUTCHR1
1404: 8600+11	A94F  C5      		PUSH	B
1405: 8611+17	A950  CD23A9  		CALL	CKCONSOL;check console (we don't care whats there).
1406: 8628+10	A953  C1      		POP	B
1407: 8638+11	A954  C5      		PUSH	B
1408: 8649+17	A955  CD0CB6  		CALL	CONOUT	;output (C) to the screen.
1409: 8666+10	A958  C1      		POP	B
1410: 8676+11	A959  C5      		PUSH	B
1411: 8687+13	A95A  3A0DAB  		LDA	PRTFLAG	;check printer flip-flop flag.
1412: 8700+4	A95D  B7      		ORA	A
1413: 8704+11+6	A95E  C40FB6  		CNZ	LIST	;print it also if non-zero.
1414: 8715+10	A961  C1      		POP	B
1415: 8725+5	A962  79      	OUTCHR1	MOV	A,C	;update cursors position.
1416: 8730+10	A963  210CAB  		LXI	H,CURPOS
1417: 8740+7	A966  FE7F    		CPI	DEL	;rubouts don't do anything here.
1418: 8747+5+6	A968  C8      		RZ
1419: 8752+10	A969  34      		INR	M	;bump line pointer.
1420: 8762+7	A96A  FE20    		CPI	' '	;and return if a normal character.
1421: 8769+5+6	A96C  D0      		RNC
1422: 8774+10	A96D  35      		DCR	M	;restore and check for the start of the line.
1423: 8784+7	A96E  7E      		MOV	A,M
1424: 8791+4	A96F  B7      		ORA	A
1425: 8795+5+6	A970  C8      		RZ		;ingnore control characters at the start of the line.
1426: 8800+5	A971  79      		MOV	A,C
1427: 8805+7	A972  FE08    		CPI	BS	;is it a backspace?
1428: 8812+10	A974  C279A9  		JNZ	OUTCHR2
1429: 8822+10	A977  35      		DCR	M	;yes, backup pointer.
1430: 8832+10	A978  C9      		RET
1431: 8842+7	A979  FE0A    	OUTCHR2	CPI	LF	;is it a line feed?
1432: 8849+5+6	A97B  C0      		RNZ		;ignore anything else.
1433: 8854+10	A97C  3600    		MVI	M,0	;reset pointer to start of line.
1434: 8864+10	A97E  C9      		RET
1435:				;
1436:				;   Output (A) to the screen. If it is a control character
1437:				; (other than carriage control), use ^x format.
1438:				;
1439: 8874+5	A97F  79      	SHOWIT	MOV	A,C
1440: 8879+17	A980  CD14A9  		CALL	CHKCHAR	;check character.
1441: 8896+10	A983  D290A9  		JNC	OUTCON	;not a control, use normal output.
1442: 8906+11	A986  F5      		PUSH	PSW
1443: 8917+7	A987  0E5E    		MVI	C,'^'	;for a control character, preceed it with '^'.
1444: 8924+17	A989  CD48A9  		CALL	OUTCHAR
1445: 8941+10	A98C  F1      		POP	PSW
1446: 8951+7	A98D  F640    		ORI	'@'	;and then use the letter equivelant.
1447: 8958+5	A98F  4F      		MOV	C,A
1448:				;
1449:				;   Function to output (C) to the console device and expand tabs
1450:				; if necessary.
1451:				;
1452: 8963+5	A990  79      	OUTCON	MOV	A,C
1453: 8968+7	A991  FE09    		CPI	TAB	;is it a tab?
1454: 8975+10	A993  C248A9  		JNZ	OUTCHAR	;use regular output.
1455: 8985+7	A996  0E20    	OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
1456: 8992+17	A998  CD48A9  		CALL	OUTCHAR
1457: 9009+13	A99B  3A0CAB  		LDA	CURPOS	;go until the cursor is at a multiple of 8
1458:				
1459: 9022+7	A99E  E607    		ANI	07H	;position.
1460: 9029+10	A9A0  C296A9  		JNZ	OUTCON1
1461: 9039+10	A9A3  C9      		RET
1462:				;
1463:				;   Echo a backspace character. Erase the prevoius character
1464:				; on the screen.
1465:				;
1466: 9049+17	A9A4  CDACA9  	BACKUP	CALL	BACKUP1	;backup the screen 1 place.
1467: 9066+7	A9A7  0E20    		MVI	C,' '	;then blank that character.
1468: 9073+17	A9A9  CD0CB6  		CALL	CONOUT
1469: 9090+7	A9AC  0E08    	BACKUP1	MVI	C,BS	;then back space once more.
1470: 9097+10	A9AE  C30CB6  		JMP	CONOUT
1471:				;
1472:				;   Signal a deleted line. Print a '#' at the end and start
1473:				; over.
1474:				;
1475: 9107+7	A9B1  0E23    	NEWLINE	MVI	C,'#'
1476: 9114+17	A9B3  CD48A9  		CALL	OUTCHAR	;print this.
1477: 9131+17	A9B6  CDC9A9  		CALL	OUTCRLF	;start new line.
1478: 9148+13	A9B9  3A0CAB  	NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
1479: 9161+10	A9BC  210BAB  		LXI	H,STARTING
1480: 9171+7	A9BF  BE      		CMP	M
1481: 9178+5+6	A9C0  D0      		RNC		;there yet?
1482: 9183+7	A9C1  0E20    		MVI	C,' '
1483: 9190+17	A9C3  CD48A9  		CALL	OUTCHAR	;nope, keep going.
1484: 9207+10	A9C6  C3B9A9  		JMP	NEWLN1
1485:				;
1486:				;   Output a (cr) (lf) to the console device (screen).
1487:				;
1488: 9217+7	A9C9  0E0D    	OUTCRLF	MVI	C,CR
1489: 9224+17	A9CB  CD48A9  		CALL	OUTCHAR
1490: 9241+7	A9CE  0E0A    		MVI	C,LF
1491: 9248+10	A9D0  C348A9  		JMP	OUTCHAR
1492:				;
1493:				;   Print message pointed to by (BC). It will end with a '$'.
1494:				;
1495: 9258+7	A9D3  0A      	PRTMESG	LDAX	B	;check for terminating character.
1496: 9265+7	A9D4  FE24    		CPI	'$'
1497: 9272+5+6	A9D6  C8      		RZ
1498: 9277+5	A9D7  03      		INX	B
1499: 9282+11	A9D8  C5      		PUSH	B	;otherwise, bump pointer and print it.
1500: 9293+5	A9D9  4F      		MOV	C,A
1501: 9298+17	A9DA  CD90A9  		CALL	OUTCON
1502: 9315+10	A9DD  C1      		POP	B
1503: 9325+10	A9DE  C3D3A9  		JMP	PRTMESG
1504:				;
1505:				;   Function to execute a buffered read.
1506:				;
1507: 9335+13	A9E1  3A0CAB  	RDBUFF	LDA	CURPOS	;use present location as starting one.
1508: 9348+13	A9E4  320BAB  		STA	STARTING
1509: 9361+16	A9E7  2A43AB  		LHLD	PARAMS	;get the maximum buffer space.
1510: 9377+7	A9EA  4E      		MOV	C,M
1511: 9384+5	A9EB  23      		INX	H	;point to first available space.
1512: 9389+11	A9EC  E5      		PUSH	H	;and save.
1513: 9400+7	A9ED  0600    		MVI	B,0	;keep a character count.
1514: 9407+11	A9EF  C5      	RDBUF1	PUSH	B
1515: 9418+11	A9F0  E5      		PUSH	H
1516: 9429+17	A9F1  CDFBA8  	RDBUF2	CALL	GETCHAR	;get the next input character.
1517: 9446+7	A9F4  E67F    		ANI	7FH	;strip bit 7.
1518: 9453+10	A9F6  E1      		POP	H	;reset registers.
1519: 9463+10	A9F7  C1      		POP	B
1520: 9473+7	A9F8  FE0D    		CPI	CR	;en of the line?
1521: 9480+10	A9FA  CAC1AA  		JZ	RDBUF17
1522: 9490+7	A9FD  FE0A    		CPI	LF
1523: 9497+10	A9FF  CAC1AA  		JZ	RDBUF17
1524: 9507+7	AA02  FE08    		CPI	BS	;how about a backspace?
1525: 9514+10	AA04  C216AA  		JNZ	RDBUF3
1526: 9524+5	AA07  78      		MOV	A,B	;yes, but ignore at the beginning of the line.
1527: 9529+4	AA08  B7      		ORA	A
1528: 9533+10	AA09  CAEFA9  		JZ	RDBUF1
1529: 9543+5	AA0C  05      		DCR	B	;ok, update counter.
1530: 9548+13	AA0D  3A0CAB  		LDA	CURPOS	;if we backspace to the start of the line,
1531: 9561+13	AA10  320AAB  		STA	OUTFLAG	;treat as a cancel (control-x).
1532: 9574+10	AA13  C370AA  		JMP	RDBUF10
1533: 9584+7	AA16  FE7F    	RDBUF3	CPI	DEL	;user typed a rubout?
1534: 9591+10	AA18  C226AA  		JNZ	RDBUF4
1535: 9601+5	AA1B  78      		MOV	A,B	;ignore at the start of the line.
1536: 9606+4	AA1C  B7      		ORA	A
1537: 9610+10	AA1D  CAEFA9  		JZ	RDBUF1
1538: 9620+7	AA20  7E      		MOV	A,M	;ok, echo the prevoius character.
1539: 9627+5	AA21  05      		DCR	B	;and reset pointers (counters).
1540: 9632+5	AA22  2B      		DCX	H
1541: 9637+10	AA23  C3A9AA  		JMP	RDBUF15
1542: 9647+7	AA26  FE05    	RDBUF4	CPI	CNTRLE	;physical end of line?
1543: 9654+10	AA28  C237AA  		JNZ	RDBUF5
1544: 9664+11	AA2B  C5      		PUSH	B	;yes, do it.
1545: 9675+11	AA2C  E5      		PUSH	H
1546: 9686+17	AA2D  CDC9A9  		CALL	OUTCRLF
1547: 9703+4	AA30  AF      		XRA	A	;and update starting position.
1548: 9707+13	AA31  320BAB  		STA	STARTING
1549: 9720+10	AA34  C3F1A9  		JMP	RDBUF2
1550: 9730+7	AA37  FE10    	RDBUF5	CPI	CNTRLP	;control-p?
1551: 9737+10	AA39  C248AA  		JNZ	RDBUF6
1552: 9747+11	AA3C  E5      		PUSH	H	;yes, flip the print flag filp-flop byte.
1553: 9758+10	AA3D  210DAB  		LXI	H,PRTFLAG
1554: 9768+7	AA40  3E01    		MVI	A,1	;PRTFLAG=1-PRTFLAG
1555: 9775+7	AA42  96      		SUB	M
1556: 9782+7	AA43  77      		MOV	M,A
1557: 9789+10	AA44  E1      		POP	H
1558: 9799+10	AA45  C3EFA9  		JMP	RDBUF1
1559: 9809+7	AA48  FE18    	RDBUF6	CPI	CNTRLX	;control-x (cancel)?
1560: 9816+10	AA4A  C25FAA  		JNZ	RDBUF8
1561: 9826+10	AA4D  E1      		POP	H
1562: 9836+13	AA4E  3A0BAB  	RDBUF7	LDA	STARTING;yes, backup the cursor to here.
1563: 9849+10	AA51  210CAB  		LXI	H,CURPOS
1564: 9859+7	AA54  BE      		CMP	M
1565: 9866+10	AA55  D2E1A9  		JNC	RDBUFF	;done yet?
1566: 9876+10	AA58  35      		DCR	M	;no, decrement pointer and output back up one space.
1567: 9886+17	AA59  CDA4A9  		CALL	BACKUP
1568: 9903+10	AA5C  C34EAA  		JMP	RDBUF7
1569: 9913+7	AA5F  FE15    	RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
1570: 9920+10	AA61  C26BAA  		JNZ	RDBUF9
1571: 9930+17	AA64  CDB1A9  		CALL	NEWLINE	;start a new line.
1572: 9947+10	AA67  E1      		POP	H
1573: 9957+10	AA68  C3E1A9  		JMP	RDBUFF
1574: 9967+7	AA6B  FE12    	RDBUF9	CPI	CNTRLR	;control-r?
1575: 9974+10	AA6D  C2A6AA  		JNZ	RDBUF14
1576: 9984+11	AA70  C5      	RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
1577: 9995+17	AA71  CDB1A9  		CALL	NEWLINE
1578:10012+10	AA74  C1      		POP	B
1579:10022+10	AA75  E1      		POP	H
1580:10032+11	AA76  E5      		PUSH	H
1581:10043+11	AA77  C5      		PUSH	B
1582:10054+5	AA78  78      	RDBUF11	MOV	A,B	;done whole line yet?
1583:10059+4	AA79  B7      		ORA	A
1584:10063+10	AA7A  CA8AAA  		JZ	RDBUF12
1585:10073+5	AA7D  23      		INX	H	;nope, get next character.
1586:10078+7	AA7E  4E      		MOV	C,M
1587:10085+5	AA7F  05      		DCR	B	;count it.
1588:10090+11	AA80  C5      		PUSH	B
1589:10101+11	AA81  E5      		PUSH	H
1590:10112+17	AA82  CD7FA9  		CALL	SHOWIT	;and display it.
1591:10129+10	AA85  E1      		POP	H
1592:10139+10	AA86  C1      		POP	B
1593:10149+10	AA87  C378AA  		JMP	RDBUF11
1594:10159+11	AA8A  E5      	RDBUF12	PUSH	H	;done with line. If we were displaying
1595:10170+13	AA8B  3A0AAB  		LDA	OUTFLAG	;then update cursor position.
1596:10183+4	AA8E  B7      		ORA	A
1597:10187+10	AA8F  CAF1A9  		JZ	RDBUF2
1598:10197+10	AA92  210CAB  		LXI	H,CURPOS;because this line is shorter, we must
1599:10207+7	AA95  96      		SUB	M	;back up the cursor (not the screen however)
1600:10214+13	AA96  320AAB  		STA	OUTFLAG	;some number of positions.
1601:10227+17	AA99  CDA4A9  	RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1602:10244+10	AA9C  210AAB  		LXI	H,OUTFLAG;zero, the screen will not be changed.
1603:10254+10	AA9F  35      		DCR	M
1604:10264+10	AAA0  C299AA  		JNZ	RDBUF13
1605:10274+10	AAA3  C3F1A9  		JMP	RDBUF2	;now just get the next character.
1606:				;
1607:				;   Just a normal character, put this in our buffer and echo.
1608:				;
1609:10284+5	AAA6  23      	RDBUF14	INX	H
1610:10289+7	AAA7  77      		MOV	M,A	;store character.
1611:10296+5	AAA8  04      		INR	B	;and count it.
1612:10301+11	AAA9  C5      	RDBUF15	PUSH	B
1613:10312+11	AAAA  E5      		PUSH	H
1614:10323+5	AAAB  4F      		MOV	C,A	;echo it now.
1615:10328+17	AAAC  CD7FA9  		CALL	SHOWIT
1616:10345+10	AAAF  E1      		POP	H
1617:10355+10	AAB0  C1      		POP	B
1618:10365+7	AAB1  7E      		MOV	A,M	;was it an abort request?
1619:10372+7	AAB2  FE03    		CPI	CNTRLC	;control-c abort?
1620:10379+5	AAB4  78      		MOV	A,B
1621:10384+10	AAB5  C2BDAA  		JNZ	RDBUF16
1622:10394+7	AAB8  FE01    		CPI	1	;only if at start of line.
1623:10401+10	AABA  CA0000  		JZ	0
1624:10411+4	AABD  B9      	RDBUF16	CMP	C	;nope, have we filled the buffer?
1625:10415+10	AABE  DAEFA9  		JC	RDBUF1
1626:10425+10	AAC1  E1      	RDBUF17	POP	H	;yes end the line and return.
1627:10435+7	AAC2  70      		MOV	M,B
1628:10442+7	AAC3  0E0D    		MVI	C,CR
1629:10449+10	AAC5  C348A9  		JMP	OUTCHAR	;output (cr) and return.
1630:				;
1631:				;   Function to get a character from the console device.
1632:				;
1633:10459+17	AAC8  CD06A9  	GETCON	CALL	GETECHO	;get and echo.
1634:10476+10	AACB  C301AB  		JMP	SETSTAT	;save status and return.
1635:				;
1636:				;   Function to get a character from the tape reader device.
1637:				;
1638:10486+17	AACE  CD15B6  	GETRDR	CALL	READER	;get a character from reader, set status and return.
1639:10503+10	AAD1  C301AB  		JMP	SETSTAT
1640:				;
1641:				;  Function to perform direct console i/o. If (C) contains (FF)
1642:				; then this is an input request. If (C) contains (FE) then
1643:				; this is a status request. Otherwise we are to output (C).
1644:				;
1645:10513+5	AAD4  79      	DIRCIO	MOV	A,C	;test for (FF).
1646:10518+5	AAD5  3C      		INR	A
1647:10523+10	AAD6  CAE0AA  		JZ	DIRC1
1648:10533+5	AAD9  3C      		INR	A	;test for (FE).
1649:10538+10	AADA  CA06B6  		JZ	CONST
1650:10548+10	AADD  C30CB6  		JMP	CONOUT	;just output (C).
1651:10558+17	AAE0  CD06B6  	DIRC1	CALL	CONST	;this is an input request.
1652:10575+4	AAE3  B7      		ORA	A
1653:10579+10	AAE4  CA91B5  		JZ	GOBACK1	;not ready? Just return (directly).
1654:10589+17	AAE7  CD09B6  		CALL	CONIN	;yes, get character.
1655:10606+10	AAEA  C301AB  		JMP	SETSTAT	;set status and return.
1656:				;
1657:				;   Function to return the i/o byte.
1658:				;
1659:10616+13	AAED  3A0300  	GETIOB	LDA	IOBYTE
1660:10629+10	AAF0  C301AB  		JMP	SETSTAT
1661:				;
1662:				;   Function to set the i/o byte.
1663:				;
1664:10639+10	AAF3  210300  	SETIOB	LXI	H,IOBYTE
1665:10649+7	AAF6  71      		MOV	M,C
1666:10656+10	AAF7  C9      		RET
1667:				;
1668:				;   Function to print the character string pointed to by (DE)
1669:				; on the console device. The string ends with a '$'.
1670:				;
1671:10666+4	AAF8  EB      	PRTSTR	XCHG
1672:10670+5	AAF9  4D      		MOV	C,L
1673:10675+5	AAFA  44      		MOV	B,H	;now (BC) points to it.
1674:10680+10	AAFB  C3D3A9  		JMP	PRTMESG
1675:				;
1676:				;   Function to interigate the console device.
1677:				;
1678:10690+17	AAFE  CD23A9  	GETCSTS	CALL	CKCONSOL
1679:				;
1680:				;   Get here to set the status and return to the cleanup
1681:				; section. Then back to the user.
1682:				;
1683:10707+13	AB01  3245AB  	SETSTAT	STA	STATUS
1684:10720+10	AB04  C9      	RTN	RET
1685:				;
1686:				;   Set the status to 1 (read or write error code).
1687:				;
1688:10730+7	AB05  3E01    	IOERR1	MVI	A,1
1689:10737+10	AB07  C301AB  		JMP	SETSTAT
1690:				;
1691:     -	AB0A  00      	OUTFLAG	DB	0	;output flag (non zero means no output).
1692:     -	AB0B  02      	STARTING:DB	2	;starting position for cursor.
1693:     -	AB0C  00      	CURPOS	DB	0	;cursor position (0=start of line).
1694:     -	AB0D  00      	PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
1695:     -	AB0E  00      	CHARBUF	DB	0	;single input character buffer.
1696:				;
1697:				;   Stack area for BDOS calls.
1698:				;
1699:     -	AB0F  0000    	USRSTACK:DW	0	;save users stack pointer here.
1700:				;
1701:     -	AB11  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1702:     -	AB1D  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1703:     -	AB29  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1704:     -	AB35  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1705:     -	AB41          	STKAREA	EQU	$	;end of stack area.
1706:				;
1707:     -	AB41  00      	USERNO	DB	0	;current user number.
1708:     -	AB42  00      	ACTIVE	DB	0	;currently active drive.
1709:     -	AB43  0000    	PARAMS	DW	0	;save (DE) parameters here on entry.
1710:     -	AB45  0000    	STATUS	DW	0	;status returned from bdos function.
1711:				;
1712:				;   Select error occured, jump to error routine.
1713:				;
1714:10747+10	AB47  210BA8  	SLCTERR	LXI	H,BADSLCT
1715:				;
1716:				;   Jump to (HL) indirectly.
1717:				;
1718:10757+7	AB4A  5E      	JUMPHL	MOV	E,M
1719:10764+5	AB4B  23      		INX	H
1720:10769+7	AB4C  56      		MOV	D,M	;now (DE) contain the desired address.
1721:10776+4	AB4D  EB      		XCHG
1722:10780+5	AB4E  E9      		PCHL
1723:				;
1724:				;   Block move. (DE) to (HL), (C) bytes total.
1725:				;
1726:10785+5	AB4F  0C      	DE2HL	INR	C	;is count down to zero?
1727:10790+5	AB50  0D      	DE2HL1	DCR	C
1728:10795+5+6	AB51  C8      		RZ		;yes, we are done.
1729:10800+7	AB52  1A      		LDAX	D	;no, move one more byte.
1730:10807+7	AB53  77      		MOV	M,A
1731:10814+5	AB54  13      		INX	D
1732:10819+5	AB55  23      		INX	H
1733:10824+10	AB56  C350AB  		JMP	DE2HL1	;and repeat.
1734:				;
1735:				;   Select the desired drive.
1736:				;
1737:10834+13	AB59  3A42AB  	SELECT	LDA	ACTIVE	;get active disk.
1738:10847+5	AB5C  4F      		MOV	C,A
1739:10852+17	AB5D  CD1BB6  		CALL	SELDSK	;select it.
1740:10869+5	AB60  7C      		MOV	A,H	;valid drive?
1741:10874+4	AB61  B5      		ORA	L	;valid drive?
1742:10878+5+6	AB62  C8      		RZ		;return if not.
1743:				;
1744:				;   Here, the BIOS returned the address of the parameter block
1745:				; in (HL). We will extract the necessary pointers and save them.
1746:				;
1747:10883+7	AB63  5E      		MOV	E,M	;yes, get address of translation table into (DE).
1748:10890+5	AB64  23      		INX	H
1749:10895+7	AB65  56      		MOV	D,M
1750:10902+5	AB66  23      		INX	H
1751:10907+16	AB67  22B3B5  		SHLD	SCRATCH1	;save pointers to scratch areas.
1752:10923+5	AB6A  23      		INX	H
1753:10928+5	AB6B  23      		INX	H
1754:10933+16	AB6C  22B5B5  		SHLD	SCRATCH2	;ditto.
1755:10949+5	AB6F  23      		INX	H
1756:10954+5	AB70  23      		INX	H
1757:10959+16	AB71  22B7B5  		SHLD	SCRATCH3	;ditto.
1758:10975+5	AB74  23      		INX	H
1759:10980+5	AB75  23      		INX	H
1760:10985+4	AB76  EB      		XCHG		;now save the translation table address.
1761:10989+16	AB77  22D0B5  		SHLD	XLATE
1762:11005+10	AB7A  21B9B5  		LXI	H,DIRBUF	;put the next 8 bytes here.
1763:11015+7	AB7D  0E08    		MVI	C,8	;they consist of the directory buffer
1764:11022+17	AB7F  CD4FAB  		CALL	DE2HL	;pointer, parameter block pointer,
1765:11039+16	AB82  2ABBB5  		LHLD	DISKPB	;check and allocation vectors.
1766:11055+4	AB85  EB      		XCHG
1767:11059+10	AB86  21C1B5  		LXI	H,SECTORS	;move parameter block into our ram.
1768:11069+7	AB89  0E0F    		MVI	C,15	;it is 15 bytes long.
1769:11076+17	AB8B  CD4FAB  		CALL	DE2HL
1770:11093+16	AB8E  2AC6B5  		LHLD	DSKSIZE	;check disk size.
1771:11109+5	AB91  7C      		MOV	A,H	;more than 256 blocks on this?
1772:11114+10	AB92  21DDB5  		LXI	H,BIGDISK
1773:11124+10	AB95  36FF    		MVI	M,0FFH	;set to samll.
1774:11134+4	AB97  B7      		ORA	A
1775:11138+10	AB98  CA9DAB  		JZ	SELECT1
1776:11148+10	AB9B  3600    		MVI	M,0	;wrong, set to large.
1777:11158+7	AB9D  3EFF    	SELECT1	MVI	A,0FFH	;clear the zero flag.
1778:11165+4	AB9F  B7      		ORA	A
1779:11169+10	ABA0  C9      		RET
1780:				;
1781:				;   Routine to home the disk track head and clear pointers.
1782:				;
1783:11179+17	ABA1  CD18B6  	HOMEDRV	CALL	HOME	;home the head.
1784:11196+4	ABA4  AF      		XRA	A
1785:11200+16	ABA5  2AB5B5  		LHLD	SCRATCH2;set our track pointer also.
1786:11216+7	ABA8  77      		MOV	M,A
1787:11223+5	ABA9  23      		INX	H
1788:11228+7	ABAA  77      		MOV	M,A
1789:11235+16	ABAB  2AB7B5  		LHLD	SCRATCH3;and our sector pointer.
1790:11251+7	ABAE  77      		MOV	M,A
1791:11258+5	ABAF  23      		INX	H
1792:11263+7	ABB0  77      		MOV	M,A
1793:11270+10	ABB1  C9      		RET
1794:				;
1795:				;   Do the actual disk read and check the error return status.
1796:				;
1797:11280+17	ABB2  CD27B6  	DOREAD	CALL	READ
1798:11297+10	ABB5  C3BBAB  		JMP	IORET
1799:				;
1800:				;   Do the actual disk write and handle any bios error.
1801:				;
1802:11307+17	ABB8  CD2AB6  	DOWRITE	CALL	WRITE
1803:11324+4	ABBB  B7      	IORET	ORA	A
1804:11328+5+6	ABBC  C8      		RZ		;return unless an error occured.
1805:11333+10	ABBD  2109A8  		LXI	H,BADSCTR;bad read/write on this sector.
1806:11343+10	ABC0  C34AAB  		JMP	JUMPHL
1807:				;
1808:				;   Routine to select the track and sector that the desired
1809:				; block number falls in.
1810:				;
1811:11353+16	ABC3  2AEAB5  	TRKSEC	LHLD	FILEPOS	;get position of last accessed file
1812:11369+7	ABC6  0E02    		MVI	C,2	;in directory and compute sector #.
1813:11376+17	ABC8  CDEAAC  		CALL	SHIFTR	;sector #=file-position/4.
1814:11393+16	ABCB  22E5B5  		SHLD	BLKNMBR	;save this as the block number of interest.
1815:11409+16	ABCE  22ECB5  		SHLD	CKSUMTBL;what's it doing here too?
1816:				;
1817:				;   if the sector number has already been set (BLKNMBR), enter
1818:				; at this point.
1819:				;
1820:11425+10	ABD1  21E5B5  	TRKSEC1	LXI	H,BLKNMBR
1821:11435+7	ABD4  4E      		MOV	C,M	;move sector number into (BC).
1822:11442+5	ABD5  23      		INX	H
1823:11447+7	ABD6  46      		MOV	B,M
1824:11454+16	ABD7  2AB7B5  		LHLD	SCRATCH3;get current sector number and
1825:11470+7	ABDA  5E      		MOV	E,M	;move this into (DE).
1826:11477+5	ABDB  23      		INX	H
1827:11482+7	ABDC  56      		MOV	D,M
1828:11489+16	ABDD  2AB5B5  		LHLD	SCRATCH2;get current track number.
1829:11505+7	ABE0  7E      		MOV	A,M	;and this into (HL).
1830:11512+5	ABE1  23      		INX	H
1831:11517+7	ABE2  66      		MOV	H,M
1832:11524+5	ABE3  6F      		MOV	L,A
1833:11529+5	ABE4  79      	TRKSEC2	MOV	A,C	;is desired sector before current one?
1834:11534+4	ABE5  93      		SUB	E
1835:11538+5	ABE6  78      		MOV	A,B
1836:11543+4	ABE7  9A      		SBB	D
1837:11547+10	ABE8  D2FAAB  		JNC	TRKSEC3
1838:11557+11	ABEB  E5      		PUSH	H	;yes, decrement sectors by one track.
1839:11568+16	ABEC  2AC1B5  		LHLD	SECTORS	;get sectors per track.
1840:11584+5	ABEF  7B      		MOV	A,E
1841:11589+4	ABF0  95      		SUB	L
1842:11593+5	ABF1  5F      		MOV	E,A
1843:11598+5	ABF2  7A      		MOV	A,D
1844:11603+4	ABF3  9C      		SBB	H
1845:11607+5	ABF4  57      		MOV	D,A	;now we have backed up one full track.
1846:11612+10	ABF5  E1      		POP	H
1847:11622+5	ABF6  2B      		DCX	H	;adjust track counter.
1848:11627+10	ABF7  C3E4AB  		JMP	TRKSEC2
1849:11637+11	ABFA  E5      	TRKSEC3	PUSH	H	;desired sector is after current one.
1850:11648+16	ABFB  2AC1B5  		LHLD	SECTORS	;get sectors per track.
1851:11664+10	ABFE  19      		DAD	D	;bump sector pointer to next track.
1852:11674+10	ABFF  DA0FAC  		JC	TRKSEC4
1853:11684+5	AC02  79      		MOV	A,C	;is desired sector now before current one?
1854:11689+4	AC03  95      		SUB	L
1855:11693+5	AC04  78      		MOV	A,B
1856:11698+4	AC05  9C      		SBB	H
1857:11702+10	AC06  DA0FAC  		JC	TRKSEC4
1858:11712+4	AC09  EB      		XCHG		;not yes, increment track counter
1859:11716+10	AC0A  E1      		POP	H	;and continue until it is.
1860:11726+5	AC0B  23      		INX	H
1861:11731+10	AC0C  C3FAAB  		JMP	TRKSEC3
1862:				;
1863:				;   here we have determined the track number that contains the
1864:				; desired sector.
1865:				;
1866:11741+10	AC0F  E1      	TRKSEC4	POP	H	;get track number (HL).
1867:11751+11	AC10  C5      		PUSH	B
1868:11762+11	AC11  D5      		PUSH	D
1869:11773+11	AC12  E5      		PUSH	H
1870:11784+4	AC13  EB      		XCHG
1871:11788+16	AC14  2ACEB5  		LHLD	OFFSET	;adjust for first track offset.
1872:11804+10	AC17  19      		DAD	D
1873:11814+5	AC18  44      		MOV	B,H
1874:11819+5	AC19  4D      		MOV	C,L
1875:11824+17	AC1A  CD1EB6  		CALL	SETTRK	;select this track.
1876:11841+10	AC1D  D1      		POP	D	;reset current track pointer.
1877:11851+16	AC1E  2AB5B5  		LHLD	SCRATCH2
1878:11867+7	AC21  73      		MOV	M,E
1879:11874+5	AC22  23      		INX	H
1880:11879+7	AC23  72      		MOV	M,D
1881:11886+10	AC24  D1      		POP	D
1882:11896+16	AC25  2AB7B5  		LHLD	SCRATCH3;reset the first sector on this track.
1883:11912+7	AC28  73      		MOV	M,E
1884:11919+5	AC29  23      		INX	H
1885:11924+7	AC2A  72      		MOV	M,D
1886:11931+10	AC2B  C1      		POP	B
1887:11941+5	AC2C  79      		MOV	A,C	;now subtract the desired one.
1888:11946+4	AC2D  93      		SUB	E	;to make it relative (1-# sectors/track).
1889:11950+5	AC2E  4F      		MOV	C,A
1890:11955+5	AC2F  78      		MOV	A,B
1891:11960+4	AC30  9A      		SBB	D
1892:11964+5	AC31  47      		MOV	B,A
1893:11969+16	AC32  2AD0B5  		LHLD	XLATE	;translate this sector according to this table.
1894:11985+4	AC35  EB      		XCHG
1895:11989+17	AC36  CD30B6  		CALL	SECTRN	;let the bios translate it.
1896:12006+5	AC39  4D      		MOV	C,L
1897:12011+5	AC3A  44      		MOV	B,H
1898:12016+10	AC3B  C321B6  		JMP	SETSEC	;and select it.
1899:				;
1900:				;   Compute block number from record number (SAVNREC) and
1901:				; extent number (SAVEXT).
1902:				;
1903:12026+10	AC3E  21C3B5  	GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
1904:12036+7	AC41  4E      		MOV	C,M	;note that this is base 2 log of ratio.
1905:12043+13	AC42  3AE3B5  		LDA	SAVNREC	;get record number.
1906:12056+4	AC45  B7      	GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
1907:12060+4	AC46  1F      		RAR
1908:12064+5	AC47  0D      		DCR	C
1909:12069+10	AC48  C245AC  		JNZ	GETBLK1
1910:12079+5	AC4B  47      		MOV	B,A	;save result in (B).
1911:12084+7	AC4C  3E08    		MVI	A,8
1912:12091+7	AC4E  96      		SUB	M
1913:12098+5	AC4F  4F      		MOV	C,A	;compute (C)=8-BLKSHFT.
1914:12103+13	AC50  3AE2B5  		LDA	SAVEXT
1915:12116+5	AC53  0D      	GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
1916:12121+10	AC54  CA5CAC  		JZ	GETBLK3
1917:12131+4	AC57  B7      		ORA	A
1918:12135+4	AC58  17      		RAL
1919:12139+10	AC59  C353AC  		JMP	GETBLK2
1920:12149+4	AC5C  80      	GETBLK3	ADD	B
1921:12153+10	AC5D  C9      		RET
1922:				;
1923:				;   Routine to extract the (BC) block byte from the fcb pointed
1924:				; to by (PARAMS). If this is a big-disk, then these are 16 bit
1925:				; block numbers, else they are 8 bit numbers.
1926:				; Number is returned in (HL).
1927:				;
1928:12163+16	AC5E  2A43AB  	EXTBLK	LHLD	PARAMS	;get fcb address.
1929:12179+10	AC61  111000  		LXI	D,16	;block numbers start 16 bytes into fcb.
1930:12189+10	AC64  19      		DAD	D
1931:12199+10	AC65  09      		DAD	B
1932:12209+13	AC66  3ADDB5  		LDA	BIGDISK	;are we using a big-disk?
1933:12222+4	AC69  B7      		ORA	A
1934:12226+10	AC6A  CA71AC  		JZ	EXTBLK1
1935:12236+7	AC6D  6E      		MOV	L,M	;no, extract an 8 bit number from the fcb.
1936:12243+7	AC6E  2600    		MVI	H,0
1937:12250+10	AC70  C9      		RET
1938:12260+10	AC71  09      	EXTBLK1	DAD	B	;yes, extract a 16 bit number.
1939:12270+7	AC72  5E      		MOV	E,M
1940:12277+5	AC73  23      		INX	H
1941:12282+7	AC74  56      		MOV	D,M
1942:12289+4	AC75  EB      		XCHG		;return in (HL).
1943:12293+10	AC76  C9      		RET
1944:				;
1945:				;   Compute block number.
1946:				;
1947:12303+17	AC77  CD3EAC  	COMBLK	CALL	GETBLOCK
1948:12320+5	AC7A  4F      		MOV	C,A
1949:12325+7	AC7B  0600    		MVI	B,0
1950:12332+17	AC7D  CD5EAC  		CALL	EXTBLK
1951:12349+16	AC80  22E5B5  		SHLD	BLKNMBR
1952:12365+10	AC83  C9      		RET
1953:				;
1954:				;   Check for a zero block number (unused).
1955:				;
1956:12375+16	AC84  2AE5B5  	CHKBLK	LHLD	BLKNMBR
1957:12391+5	AC87  7D      		MOV	A,L	;is it zero?
1958:12396+4	AC88  B4      		ORA	H
1959:12400+10	AC89  C9      		RET
1960:				;
1961:				;   Adjust physical block (BLKNMBR) and convert to logical
1962:				; sector (LOGSECT). This is the starting sector of this block.
1963:				; The actual sector of interest is then added to this and the
1964:				; resulting sector number is stored back in (BLKNMBR). This
1965:				; will still have to be adjusted for the track number.
1966:				;
1967:12410+13	AC8A  3AC3B5  	LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
1968:12423+16	AC8D  2AE5B5  		LHLD	BLKNMBR	;get physical sector desired.
1969:12439+10	AC90  29      	LOGICL1	DAD	H	;compute logical sector number.
1970:12449+5	AC91  3D      		DCR	A	;note logical sectors are 128 bytes long.
1971:12454+10	AC92  C290AC  		JNZ	LOGICL1
1972:12464+16	AC95  22E7B5  		SHLD	LOGSECT	;save logical sector.
1973:12480+13	AC98  3AC4B5  		LDA	BLKMASK	;get block mask.
1974:12493+5	AC9B  4F      		MOV	C,A
1975:12498+13	AC9C  3AE3B5  		LDA	SAVNREC	;get next sector to access.
1976:12511+4	AC9F  A1      		ANA	C	;extract the relative position within physical block.
1977:12515+4	ACA0  B5      		ORA	L	;and add it too logical sector.
1978:12519+5	ACA1  6F      		MOV	L,A
1979:12524+16	ACA2  22E5B5  		SHLD	BLKNMBR	;and store.
1980:12540+10	ACA5  C9      		RET
1981:				;
1982:				;   Set (HL) to point to extent byte in fcb.
1983:				;
1984:12550+16	ACA6  2A43AB  	SETEXT	LHLD	PARAMS
1985:12566+10	ACA9  110C00  		LXI	D,12	;it is the twelth byte.
1986:12576+10	ACAC  19      		DAD	D
1987:12586+10	ACAD  C9      		RET
1988:				;
1989:				;   Set (HL) to point to record count byte in fcb and (DE) to
1990:				; next record number byte.
1991:				;
1992:12596+16	ACAE  2A43AB  	SETHLDE	LHLD	PARAMS
1993:12612+10	ACB1  110F00  		LXI	D,15	;record count byte (#15).
1994:12622+10	ACB4  19      		DAD	D
1995:12632+4	ACB5  EB      		XCHG
1996:12636+10	ACB6  211100  		LXI	H,17	;next record number (#32).
1997:12646+10	ACB9  19      		DAD	D
1998:12656+10	ACBA  C9      		RET
1999:				;
2000:				;   Save current file data from fcb.
2001:				;
2002:12666+17	ACBB  CDAEAC  	STRDATA	CALL	SETHLDE
2003:12683+7	ACBE  7E      		MOV	A,M	;get and store record count byte.
2004:12690+13	ACBF  32E3B5  		STA	SAVNREC
2005:12703+4	ACC2  EB      		XCHG
2006:12707+7	ACC3  7E      		MOV	A,M	;get and store next record number byte.
2007:12714+13	ACC4  32E1B5  		STA	SAVNXT
2008:12727+17	ACC7  CDA6AC  		CALL	SETEXT	;point to extent byte.
2009:12744+13	ACCA  3AC5B5  		LDA	EXTMASK	;get extent mask.
2010:12757+7	ACCD  A6      		ANA	M
2011:12764+13	ACCE  32E2B5  		STA	SAVEXT	;and save extent here.
2012:12777+10	ACD1  C9      		RET
2013:				;
2014:				;   Set the next record to access. If (MODE) is set to 2, then
2015:				; the last record byte (SAVNREC) has the correct number to access.
2016:				; For sequential access, (MODE) will be equal to 1.
2017:				;
2018:12787+17	ACD2  CDAEAC  	SETNREC	CALL	SETHLDE
2019:12804+13	ACD5  3AD5B5  		LDA	MODE	;get sequential flag (=1).
2020:12817+7	ACD8  FE02    		CPI	2	;a 2 indicates that no adder is needed.
2021:12824+10	ACDA  C2DEAC  		JNZ	STNREC1
2022:12834+4	ACDD  AF      		XRA	A	;clear adder (random access?).
2023:12838+5	ACDE  4F      	STNREC1	MOV	C,A
2024:12843+13	ACDF  3AE3B5  		LDA	SAVNREC	;get last record number.
2025:12856+4	ACE2  81      		ADD	C	;increment record count.
2026:12860+7	ACE3  77      		MOV	M,A	;and set fcb's next record byte.
2027:12867+4	ACE4  EB      		XCHG
2028:12871+13	ACE5  3AE1B5  		LDA	SAVNXT	;get next record byte from storage.
2029:12884+7	ACE8  77      		MOV	M,A	;and put this into fcb as number of records used.
2030:12891+10	ACE9  C9      		RET
2031:				;
2032:				;   Shift (HL) right (C) bits.
2033:				;
2034:12901+5	ACEA  0C      	SHIFTR	INR	C
2035:12906+5	ACEB  0D      	SHIFTR1	DCR	C
2036:12911+5+6	ACEC  C8      		RZ
2037:12916+5	ACED  7C      		MOV	A,H
2038:12921+4	ACEE  B7      		ORA	A
2039:12925+4	ACEF  1F      		RAR
2040:12929+5	ACF0  67      		MOV	H,A
2041:12934+5	ACF1  7D      		MOV	A,L
2042:12939+4	ACF2  1F      		RAR
2043:12943+5	ACF3  6F      		MOV	L,A
2044:12948+10	ACF4  C3EBAC  		JMP	SHIFTR1
2045:				;
2046:				;   Compute the check-sum for the directory buffer. Return
2047:				; integer sum in (A).
2048:				;
2049:12958+7	ACF7  0E80    	CHECKSUM:MVI	C,128	;length of buffer.
2050:12965+16	ACF9  2AB9B5  		LHLD	DIRBUF	;get its location.
2051:12981+4	ACFC  AF      		XRA	A	;clear summation byte.
2052:12985+7	ACFD  86      	CHKSUM1	ADD	M	;and compute sum ignoring carries.
2053:12992+5	ACFE  23      		INX	H
2054:12997+5	ACFF  0D      		DCR	C
2055:13002+10	AD00  C2FDAC  		JNZ	CHKSUM1
2056:13012+10	AD03  C9      		RET
2057:				;
2058:				;   Shift (HL) left (C) bits.
2059:				;
2060:13022+5	AD04  0C      	SHIFTL	INR	C
2061:13027+5	AD05  0D      	SHIFTL1	DCR	C
2062:13032+5+6	AD06  C8      		RZ
2063:13037+10	AD07  29      		DAD	H	;shift left 1 bit.
2064:13047+10	AD08  C305AD  		JMP	SHIFTL1
2065:				;
2066:				;   Routine to set a bit in a 16 bit value contained in (BC).
2067:				; The bit set depends on the current drive selection.
2068:				;
2069:13057+11	AD0B  C5      	SETBIT	PUSH	B	;save 16 bit word.
2070:13068+13	AD0C  3A42AB  		LDA	ACTIVE	;get active drive.
2071:13081+5	AD0F  4F      		MOV	C,A
2072:13086+10	AD10  210100  		LXI	H,1
2073:13096+17	AD13  CD04AD  		CALL	SHIFTL	;shift bit 0 into place.
2074:13113+10	AD16  C1      		POP	B	;now 'or' this with the original word.
2075:13123+5	AD17  79      		MOV	A,C
2076:13128+4	AD18  B5      		ORA	L
2077:13132+5	AD19  6F      		MOV	L,A	;low byte done, do high byte.
2078:13137+5	AD1A  78      		MOV	A,B
2079:13142+4	AD1B  B4      		ORA	H
2080:13146+5	AD1C  67      		MOV	H,A
2081:13151+10	AD1D  C9      		RET
2082:				;
2083:				;   Extract the write protect status bit for the current drive.
2084:				; The result is returned in (A), bit 0.
2085:				;
2086:13161+16	AD1E  2AADB5  	GETWPRT	LHLD	WRTPRT	;get status bytes.
2087:13177+13	AD21  3A42AB  		LDA	ACTIVE	;which drive is current?
2088:13190+5	AD24  4F      		MOV	C,A
2089:13195+17	AD25  CDEAAC  		CALL	SHIFTR	;shift status such that bit 0 is the
2090:13212+5	AD28  7D      		MOV	A,L	;one of interest for this drive.
2091:13217+7	AD29  E601    		ANI	01H	;and isolate it.
2092:13224+10	AD2B  C9      		RET
2093:				;
2094:				;   Function to write protect the current disk.
2095:				;
2096:13234+10	AD2C  21ADB5  	WRTPRTD	LXI	H,WRTPRT;point to status word.
2097:13244+7	AD2F  4E      		MOV	C,M	;set (BC) equal to the status.
2098:13251+5	AD30  23      		INX	H
2099:13256+7	AD31  46      		MOV	B,M
2100:13263+17	AD32  CD0BAD  		CALL	SETBIT	;and set this bit according to current drive.
2101:13280+16	AD35  22ADB5  		SHLD	WRTPRT	;then save.
2102:13296+16	AD38  2AC8B5  		LHLD	DIRSIZE	;now save directory size limit.
2103:13312+5	AD3B  23      		INX	H	;remember the last one.
2104:13317+4	AD3C  EB      		XCHG
2105:13321+16	AD3D  2AB3B5  		LHLD	SCRATCH1;and store it here.
2106:13337+7	AD40  73      		MOV	M,E	;put low byte.
2107:13344+5	AD41  23      		INX	H
2108:13349+7	AD42  72      		MOV	M,D	;then high byte.
2109:13356+10	AD43  C9      		RET
2110:				;
2111:				;   Check for a read only file.
2112:				;
2113:13366+17	AD44  CD5EAD  	CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2114:13383+10	AD47  110900  	CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
2115:13393+10	AD4A  19      		DAD	D
2116:13403+7	AD4B  7E      		MOV	A,M
2117:13410+4	AD4C  17      		RAL
2118:13414+5+6	AD4D  D0      		RNC		;return if ok.
2119:13419+10	AD4E  210FA8  		LXI	H,ROFILE;else, print error message and terminate.
2120:13429+10	AD51  C34AAB  		JMP	JUMPHL
2121:				;
2122:				;   Check the write protect status of the active disk.
2123:				;
2124:13439+17	AD54  CD1EAD  	CHKWPRT	CALL	GETWPRT
2125:13456+5+6	AD57  C8      		RZ		;return if ok.
2126:13461+10	AD58  210DA8  		LXI	H,RODISK;else print message and terminate.
2127:13471+10	AD5B  C34AAB  		JMP	JUMPHL
2128:				;
2129:				;   Routine to set (HL) pointing to the proper entry in the
2130:				; directory buffer.
2131:				;
2132:13481+16	AD5E  2AB9B5  	FCB2HL	LHLD	DIRBUF	;get address of buffer.
2133:13497+13	AD61  3AE9B5  		LDA	FCBPOS	;relative position of file.
2134:				;
2135:				;   Routine to add (A) to (HL).
2136:				;
2137:13510+4	AD64  85      	ADDA2HL	ADD	L
2138:13514+5	AD65  6F      		MOV	L,A
2139:13519+5+6	AD66  D0      		RNC
2140:13524+5	AD67  24      		INR	H	;take care of any carry.
2141:13529+10	AD68  C9      		RET
2142:				;
2143:				;   Routine to get the 's2' byte from the fcb supplied in
2144:				; the initial parameter specification.
2145:				;
2146:13539+16	AD69  2A43AB  	GETS2	LHLD	PARAMS	;get address of fcb.
2147:13555+10	AD6C  110E00  		LXI	D,14	;relative position of 's2'.
2148:13565+10	AD6F  19      		DAD	D
2149:13575+7	AD70  7E      		MOV	A,M	;extract this byte.
2150:13582+10	AD71  C9      		RET
2151:				;
2152:				;   Clear the 's2' byte in the fcb.
2153:				;
2154:13592+17	AD72  CD69AD  	CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
2155:13609+10	AD75  3600    		MVI	M,0	;now clear it.
2156:13619+10	AD77  C9      		RET
2157:				;
2158:				;   Set bit 7 in the 's2' byte of the fcb.
2159:				;
2160:13629+17	AD78  CD69AD  	SETS2B7	CALL	GETS2	;get the byte.
2161:13646+7	AD7B  F680    		ORI	80H	;and set bit 7.
2162:13653+7	AD7D  77      		MOV	M,A	;then store.
2163:13660+10	AD7E  C9      		RET
2164:				;
2165:				;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2166:				; the difference. This checks to see if there are more file
2167:				; names in the directory. We are at (FILEPOS) and there are
2168:				; (SCRATCH1) of them to check.
2169:				;
2170:13670+16	AD7F  2AEAB5  	MOREFLS	LHLD	FILEPOS	;we are here.
2171:13686+4	AD82  EB      		XCHG
2172:13690+16	AD83  2AB3B5  		LHLD	SCRATCH1;and don't go past here.
2173:13706+5	AD86  7B      		MOV	A,E	;compute difference but don't keep.
2174:13711+7	AD87  96      		SUB	M
2175:13718+5	AD88  23      		INX	H
2176:13723+5	AD89  7A      		MOV	A,D
2177:13728+7	AD8A  9E      		SBB	M	;set carry if no more names.
2178:13735+10	AD8B  C9      		RET
2179:				;
2180:				;   Call this routine to prevent (SCRATCH1) from being greater
2181:				; than (FILEPOS).
2182:				;
2183:13745+17	AD8C  CD7FAD  	CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
2184:13762+5+6	AD8F  D8      		RC
2185:13767+5	AD90  13      		INX	D	;yes, reset it to (FILEPOS).
2186:13772+7	AD91  72      		MOV	M,D
2187:13779+5	AD92  2B      		DCX	H
2188:13784+7	AD93  73      		MOV	M,E
2189:13791+10	AD94  C9      		RET
2190:				;
2191:				;   Compute (HL)=(DE)-(HL)
2192:				;
2193:13801+5	AD95  7B      	SUBHL	MOV	A,E	;compute difference.
2194:13806+4	AD96  95      		SUB	L
2195:13810+5	AD97  6F      		MOV	L,A	;store low byte.
2196:13815+5	AD98  7A      		MOV	A,D
2197:13820+4	AD99  9C      		SBB	H
2198:13824+5	AD9A  67      		MOV	H,A	;and then high byte.
2199:13829+10	AD9B  C9      		RET
2200:				;
2201:				;   Set the directory checksum byte.
2202:				;
2203:13839+7	AD9C  0EFF    	SETDIR	MVI	C,0FFH
2204:				;
2205:				;   Routine to set or compare the directory checksum byte. If
2206:				; (C)=0ffh, then this will set the checksum byte. Else the byte
2207:				; will be checked. If the check fails (the disk has been changed),
2208:				; then this disk will be write protected.
2209:				;
2210:13846+16	AD9E  2AECB5  	CHECKDIR:LHLD	CKSUMTBL
2211:13862+4	ADA1  EB      		XCHG
2212:13866+16	ADA2  2ACCB5  		LHLD	ALLOC1
2213:13882+17	ADA5  CD95AD  		CALL	SUBHL
2214:13899+5+6	ADA8  D0      		RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2215:13904+11	ADA9  C5      		PUSH	B
2216:13915+17	ADAA  CDF7AC  		CALL	CHECKSUM;else compute checksum.
2217:13932+16	ADAD  2ABDB5  		LHLD	CHKVECT	;get address of checksum table.
2218:13948+4	ADB0  EB      		XCHG
2219:13952+16	ADB1  2AECB5  		LHLD	CKSUMTBL
2220:13968+10	ADB4  19      		DAD	D	;set (HL) to point to byte for this drive.
2221:13978+10	ADB5  C1      		POP	B
2222:13988+5	ADB6  0C      		INR	C	;set or check ?
2223:13993+10	ADB7  CAC4AD  		JZ	CHKDIR1
2224:14003+7	ADBA  BE      		CMP	M	;check them.
2225:14010+5+6	ADBB  C8      		RZ		;return if they are the same.
2226:14015+17	ADBC  CD7FAD  		CALL	MOREFLS	;not the same, do we care?
2227:14032+5+6	ADBF  D0      		RNC
2228:14037+17	ADC0  CD2CAD  		CALL	WRTPRTD	;yes, mark this as write protected.
2229:14054+10	ADC3  C9      		RET
2230:14064+7	ADC4  77      	CHKDIR1	MOV	M,A	;just set the byte.
2231:14071+10	ADC5  C9      		RET
2232:				;
2233:				;   Do a write to the directory of the current disk.
2234:				;
2235:14081+17	ADC6  CD9CAD  	DIRWRITE:CALL	SETDIR	;set checksum byte.
2236:14098+17	ADC9  CDE0AD  		CALL	DIRDMA	;set directory dma address.
2237:14115+7	ADCC  0E01    		MVI	C,1	;tell the bios to actually write.
2238:14122+17	ADCE  CDB8AB  		CALL	DOWRITE	;then do the write.
2239:14139+10	ADD1  C3DAAD  		JMP	DEFDMA
2240:				;
2241:				;   Read from the directory.
2242:				;
2243:14149+17	ADD4  CDE0AD  	DIRREAD	CALL	DIRDMA	;set the directory dma address.
2244:14166+17	ADD7  CDB2AB  		CALL	DOREAD	;and read it.
2245:				;
2246:				;   Routine to set the dma address to the users choice.
2247:				;
2248:14183+10	ADDA  21B1B5  	DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
2249:14193+10	ADDD  C3E3AD  		JMP	DIRDMA1
2250:				;
2251:				;   Routine to set the dma address for directory work.
2252:				;
2253:14203+10	ADE0  21B9B5  	DIRDMA	LXI	H,DIRBUF
2254:				;
2255:				;   Set the dma address. On entry, (HL) points to
2256:				; word containing the desired dma address.
2257:				;
2258:14213+7	ADE3  4E      	DIRDMA1	MOV	C,M
2259:14220+5	ADE4  23      		INX	H
2260:14225+7	ADE5  46      		MOV	B,M	;setup (BC) and go to the bios to set it.
2261:14232+10	ADE6  C324B6  		JMP	SETDMA
2262:				;
2263:				;   Move the directory buffer into user's dma space.
2264:				;
2265:14242+16	ADE9  2AB9B5  	MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
2266:14258+4	ADEC  EB      		XCHG
2267:14262+16	ADED  2AB1B5  		LHLD	USERDMA; put it here.
2268:14278+7	ADF0  0E80    		MVI	C,128	;this is its length.
2269:14285+10	ADF2  C34FAB  		JMP	DE2HL	;move it now and return.
2270:				;
2271:				;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2272:				;
2273:14295+10	ADF5  21EAB5  	CKFILPOS:LXI	H,FILEPOS
2274:14305+7	ADF8  7E      		MOV	A,M
2275:14312+5	ADF9  23      		INX	H
2276:14317+7	ADFA  BE      		CMP	M	;are both bytes the same?
2277:14324+5+6	ADFB  C0      		RNZ
2278:14329+5	ADFC  3C      		INR	A	;yes, but are they each 0ffh?
2279:14334+10	ADFD  C9      		RET
2280:				;
2281:				;   Set location (FILEPOS) to 0ffffh.
2282:				;
2283:14344+10	ADFE  21FFFF  	STFILPOS:LXI	H,0FFFFH
2284:14354+16	AE01  22EAB5  		SHLD	FILEPOS
2285:14370+10	AE04  C9      		RET
2286:				;
2287:				;   Move on to the next file position within the current
2288:				; directory buffer. If no more exist, set pointer to 0ffffh
2289:				; and the calling routine will check for this. Enter with (C)
2290:				; equal to 0ffh to cause the checksum byte to be set, else we
2291:				; will check this disk and set write protect if checksums are
2292:				; not the same (applies only if another directory sector must
2293:				; be read).
2294:				;
2295:14380+16	AE05  2AC8B5  	NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
2296:14396+4	AE08  EB      		XCHG
2297:14400+16	AE09  2AEAB5  		LHLD	FILEPOS	;get current count.
2298:14416+5	AE0C  23      		INX	H	;go on to the next one.
2299:14421+16	AE0D  22EAB5  		SHLD	FILEPOS
2300:14437+17	AE10  CD95AD  		CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
2301:14454+10	AE13  D219AE  		JNC	NXENT1	;is there more room left?
2302:14464+10	AE16  C3FEAD  		JMP	STFILPOS;no. Set this flag and return.
2303:14474+13	AE19  3AEAB5  	NXENT1	LDA	FILEPOS	;get file position within directory.
2304:14487+7	AE1C  E603    		ANI	03H	;only look within this sector (only 4 entries fit).
2305:14494+7	AE1E  0605    		MVI	B,5	;convert to relative position (32 bytes each).
2306:14501+4	AE20  87      	NXENT2	ADD	A	;note that this is not efficient code.
2307:14505+5	AE21  05      		DCR	B	;5 'ADD A's would be better.
2308:14510+10	AE22  C220AE  		JNZ	NXENT2
2309:14520+13	AE25  32E9B5  		STA	FCBPOS	;save it as position of fcb.
2310:14533+4	AE28  B7      		ORA	A
2311:14537+5+6	AE29  C0      		RNZ		;return if we are within buffer.
2312:14542+11	AE2A  C5      		PUSH	B
2313:14553+17	AE2B  CDC3AB  		CALL	TRKSEC	;we need the next directory sector.
2314:14570+17	AE2E  CDD4AD  		CALL	DIRREAD
2315:14587+10	AE31  C1      		POP	B
2316:14597+10	AE32  C39EAD  		JMP	CHECKDIR
2317:				;
2318:				;   Routine to to get a bit from the disk space allocation
2319:				; map. It is returned in (A), bit position 0. On entry to here,
2320:				; set (BC) to the block number on the disk to check.
2321:				; On return, (D) will contain the original bit position for
2322:				; this block number and (HL) will point to the address for it.
2323:				;
2324:14607+5	AE35  79      	CKBITMAP:MOV	A,C	;determine bit number of interest.
2325:14612+7	AE36  E607    		ANI	07H	;compute (D)=(E)=(C and 7)+1.
2326:14619+5	AE38  3C      		INR	A
2327:14624+5	AE39  5F      		MOV	E,A	;save particular bit number.
2328:14629+5	AE3A  57      		MOV	D,A
2329:				;
2330:				;   compute (BC)=(BC)/8.
2331:				;
2332:14634+5	AE3B  79      		MOV	A,C
2333:14639+4	AE3C  0F      		RRC		;now shift right 3 bits.
2334:14643+4	AE3D  0F      		RRC
2335:14647+4	AE3E  0F      		RRC
2336:14651+7	AE3F  E61F    		ANI	1FH	;and clear bits 7,6,5.
2337:14658+5	AE41  4F      		MOV	C,A
2338:14663+5	AE42  78      		MOV	A,B
2339:14668+4	AE43  87      		ADD	A	;now shift (B) into bits 7,6,5.
2340:14672+4	AE44  87      		ADD	A
2341:14676+4	AE45  87      		ADD	A
2342:14680+4	AE46  87      		ADD	A
2343:14684+4	AE47  87      		ADD	A
2344:14688+4	AE48  B1      		ORA	C	;and add in (C).
2345:14692+5	AE49  4F      		MOV	C,A	;ok, (C) ha been completed.
2346:14697+5	AE4A  78      		MOV	A,B	;is there a better way of doing this?
2347:14702+4	AE4B  0F      		RRC
2348:14706+4	AE4C  0F      		RRC
2349:14710+4	AE4D  0F      		RRC
2350:14714+7	AE4E  E61F    		ANI	1FH
2351:14721+5	AE50  47      		MOV	B,A	;and now (B) is completed.
2352:				;
2353:				;   use this as an offset into the disk space allocation
2354:				; table.
2355:				;
2356:14726+16	AE51  2ABFB5  		LHLD	ALOCVECT
2357:14742+10	AE54  09      		DAD	B
2358:14752+7	AE55  7E      		MOV	A,M	;now get correct byte.
2359:14759+4	AE56  07      	CKBMAP1	RLC		;get correct bit into position 0.
2360:14763+5	AE57  1D      		DCR	E
2361:14768+10	AE58  C256AE  		JNZ	CKBMAP1
2362:14778+10	AE5B  C9      		RET
2363:				;
2364:				;   Set or clear the bit map such that block number (BC) will be marked
2365:				; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2366:				; 1 then it will be set (don't use anyother values).
2367:				;
2368:14788+11	AE5C  D5      	STBITMAP:PUSH	D
2369:14799+17	AE5D  CD35AE  		CALL	CKBITMAP;get the byte of interest.
2370:14816+7	AE60  E6FE    		ANI	0FEH	;clear the affected bit.
2371:14823+10	AE62  C1      		POP	B
2372:14833+4	AE63  B1      		ORA	C	;and now set it acording to (C).
2373:				;
2374:				;  entry to restore the original bit position and then store
2375:				; in table. (A) contains the value, (D) contains the bit
2376:				; position (1-8), and (HL) points to the address within the
2377:				; space allocation table for this byte.
2378:				;
2379:14837+4	AE64  0F      	STBMAP1	RRC		;restore original bit position.
2380:14841+5	AE65  15      		DCR	D
2381:14846+10	AE66  C264AE  		JNZ	STBMAP1
2382:14856+7	AE69  77      		MOV	M,A	;and stor byte in table.
2383:14863+10	AE6A  C9      		RET
2384:				;
2385:				;   Set/clear space used bits in allocation map for this file.
2386:				; On entry, (C)=1 to set the map and (C)=0 to clear it.
2387:				;
2388:14873+17	AE6B  CD5EAD  	SETFILE	CALL	FCB2HL	;get address of fcb
2389:14890+10	AE6E  111000  		LXI	D,16
2390:14900+10	AE71  19      		DAD	D	;get to block number bytes.
2391:14910+11	AE72  C5      		PUSH	B
2392:14921+7	AE73  0E11    		MVI	C,17	;check all 17 bytes (max) of table.
2393:14928+10	AE75  D1      	SETFL1	POP	D
2394:14938+5	AE76  0D      		DCR	C	;done all bytes yet?
2395:14943+5+6	AE77  C8      		RZ
2396:14948+11	AE78  D5      		PUSH	D
2397:14959+13	AE79  3ADDB5  		LDA	BIGDISK	;check disk size for 16 bit block numbers.
2398:14972+4	AE7C  B7      		ORA	A
2399:14976+10	AE7D  CA88AE  		JZ	SETFL2
2400:14986+11	AE80  C5      		PUSH	B	;only 8 bit numbers. set (BC) to this one.
2401:14997+11	AE81  E5      		PUSH	H
2402:15008+7	AE82  4E      		MOV	C,M	;get low byte from table, always
2403:15015+7	AE83  0600    		MVI	B,0	;set high byte to zero.
2404:15022+10	AE85  C38EAE  		JMP	SETFL3
2405:15032+5	AE88  0D      	SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
2406:15037+11	AE89  C5      		PUSH	B
2407:15048+7	AE8A  4E      		MOV	C,M	;now get both the low and high bytes.
2408:15055+5	AE8B  23      		INX	H
2409:15060+7	AE8C  46      		MOV	B,M
2410:15067+11	AE8D  E5      		PUSH	H
2411:15078+5	AE8E  79      	SETFL3	MOV	A,C	;block used?
2412:15083+4	AE8F  B0      		ORA	B
2413:15087+10	AE90  CA9DAE  		JZ	SETFL4
2414:15097+16	AE93  2AC6B5  		LHLD	DSKSIZE	;is this block number within the
2415:15113+5	AE96  7D      		MOV	A,L	;space on the disk?
2416:15118+4	AE97  91      		SUB	C
2417:15122+5	AE98  7C      		MOV	A,H
2418:15127+4	AE99  98      		SBB	B
2419:15131+11+6	AE9A  D45CAE  		CNC	STBITMAP;yes, set the proper bit.
2420:15142+10	AE9D  E1      	SETFL4	POP	H	;point to next block number in fcb.
2421:15152+5	AE9E  23      		INX	H
2422:15157+10	AE9F  C1      		POP	B
2423:15167+10	AEA0  C375AE  		JMP	SETFL1
2424:				;
2425:				;   Construct the space used allocation bit map for the active
2426:				; drive. If a file name starts with '$' and it is under the
2427:				; current user number, then (STATUS) is set to minus 1. Otherwise
2428:				; it is not set at all.
2429:				;
2430:15177+16	AEA3  2AC6B5  	BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
2431:15193+7	AEA6  0E03    		MVI	C,3
2432:15200+17	AEA8  CDEAAC  		CALL	SHIFTR	;(HL)=(HL)/8.
2433:15217+5	AEAB  23      		INX	H	;at lease 1 byte.
2434:15222+5	AEAC  44      		MOV	B,H
2435:15227+5	AEAD  4D      		MOV	C,L	;set (BC) to the allocation table length.
2436:				;
2437:				;   Initialize the bitmap for this drive. Right now, the first
2438:				; two bytes are specified by the disk parameter block. However
2439:				; a patch could be entered here if it were necessary to setup
2440:				; this table in a special mannor. For example, the bios could
2441:				; determine locations of 'bad blocks' and set them as already
2442:				; 'used' in the map.
2443:				;
2444:15232+16	AEAE  2ABFB5  		LHLD	ALOCVECT;now zero out the table now.
2445:15248+10	AEB1  3600    	BITMAP1	MVI	M,0
2446:15258+5	AEB3  23      		INX	H
2447:15263+5	AEB4  0B      		DCX	B
2448:15268+5	AEB5  78      		MOV	A,B
2449:15273+4	AEB6  B1      		ORA	C
2450:15277+10	AEB7  C2B1AE  		JNZ	BITMAP1
2451:15287+16	AEBA  2ACAB5  		LHLD	ALLOC0	;get initial space used by directory.
2452:15303+4	AEBD  EB      		XCHG
2453:15307+16	AEBE  2ABFB5  		LHLD	ALOCVECT;and put this into map.
2454:15323+7	AEC1  73      		MOV	M,E
2455:15330+5	AEC2  23      		INX	H
2456:15335+7	AEC3  72      		MOV	M,D
2457:				;
2458:				;   End of initialization portion.
2459:				;
2460:15342+17	AEC4  CDA1AB  		CALL	HOMEDRV	;now home the drive.
2461:15359+16	AEC7  2AB3B5  		LHLD	SCRATCH1
2462:15375+10	AECA  3603    		MVI	M,3	;force next directory request to read
2463:15385+5	AECC  23      		INX	H	;in a sector.
2464:15390+10	AECD  3600    		MVI	M,0
2465:15400+17	AECF  CDFEAD  		CALL	STFILPOS;clear initial file position also.
2466:15417+7	AED2  0EFF    	BITMAP2	MVI	C,0FFH	;read next file name in directory
2467:15424+17	AED4  CD05AE  		CALL	NXENTRY	;and set checksum byte.
2468:15441+17	AED7  CDF5AD  		CALL	CKFILPOS;is there another file?
2469:15458+5+6	AEDA  C8      		RZ
2470:15463+17	AEDB  CD5EAD  		CALL	FCB2HL	;yes, get its address.
2471:15480+7	AEDE  3EE5    		MVI	A,0E5H
2472:15487+7	AEE0  BE      		CMP	M	;empty file entry?
2473:15494+10	AEE1  CAD2AE  		JZ	BITMAP2
2474:15504+13	AEE4  3A41AB  		LDA	USERNO	;no, correct user number?
2475:15517+7	AEE7  BE      		CMP	M
2476:15524+10	AEE8  C2F6AE  		JNZ	BITMAP3
2477:15534+5	AEEB  23      		INX	H
2478:15539+7	AEEC  7E      		MOV	A,M	;yes, does name start with a '$'?
2479:15546+7	AEED  D624    		SUI	'$'
2480:15553+10	AEEF  C2F6AE  		JNZ	BITMAP3
2481:15563+5	AEF2  3D      		DCR	A	;yes, set atatus to minus one.
2482:15568+13	AEF3  3245AB  		STA	STATUS
2483:15581+7	AEF6  0E01    	BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
2484:15588+17	AEF8  CD6BAE  		CALL	SETFILE
2485:15605+17	AEFB  CD8CAD  		CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
2486:15622+10	AEFE  C3D2AE  		JMP	BITMAP2
2487:				;
2488:				;   Set the status (STATUS) and return.
2489:				;
2490:15632+13	AF01  3AD4B5  	STSTATUS:LDA	FNDSTAT
2491:15645+10	AF04  C301AB  		JMP	SETSTAT
2492:				;
2493:				;   Check extents in (A) and (C). Set the zero flag if they
2494:				; are the same. The number of 16k chunks of disk space that
2495:				; the directory extent covers is expressad is (EXTMASK+1).
2496:				; No registers are modified.
2497:				;
2498:15655+11	AF07  C5      	SAMEXT	PUSH	B
2499:15666+11	AF08  F5      		PUSH	PSW
2500:15677+13	AF09  3AC5B5  		LDA	EXTMASK	;get extent mask and use it to
2501:15690+4	AF0C  2F      		CMA		;to compare both extent numbers.
2502:15694+5	AF0D  47      		MOV	B,A	;save resulting mask here.
2503:15699+5	AF0E  79      		MOV	A,C	;mask first extent and save in (C).
2504:15704+4	AF0F  A0      		ANA	B
2505:15708+5	AF10  4F      		MOV	C,A
2506:15713+10	AF11  F1      		POP	PSW	;now mask second extent and compare
2507:15723+4	AF12  A0      		ANA	B	;with the first one.
2508:15727+4	AF13  91      		SUB	C
2509:15731+7	AF14  E61F    		ANI	1FH	;(* only check buts 0-4 *)
2510:15738+10	AF16  C1      		POP	B	;the zero flag is set if they are the same.
2511:15748+10	AF17  C9      		RET		;restore (BC) and return.
2512:				;
2513:				;   Search for the first occurence of a file name. On entry,
2514:				; register (C) should contain the number of bytes of the fcb
2515:				; that must match.
2516:				;
2517:15758+7	AF18  3EFF    	FINDFST	MVI	A,0FFH
2518:15765+13	AF1A  32D4B5  		STA	FNDSTAT
2519:15778+10	AF1D  21D8B5  		LXI	H,COUNTER;save character count.
2520:15788+7	AF20  71      		MOV	M,C
2521:15795+16	AF21  2A43AB  		LHLD	PARAMS	;get filename to match.
2522:15811+16	AF24  22D9B5  		SHLD	SAVEFCB	;and save.
2523:15827+17	AF27  CDFEAD  		CALL	STFILPOS;clear initial file position (set to 0ffffh).
2524:15844+17	AF2A  CDA1AB  		CALL	HOMEDRV	;home the drive.
2525:				;
2526:				;   Entry to locate the next occurence of a filename within the
2527:				; directory. The disk is not expected to have been changed. If
2528:				; it was, then it will be write protected.
2529:				;
2530:15861+7	AF2D  0E00    	FINDNXT	MVI	C,0	;write protect the disk if changed.
2531:15868+17	AF2F  CD05AE  		CALL	NXENTRY	;get next filename entry in directory.
2532:15885+17	AF32  CDF5AD  		CALL	CKFILPOS;is file position = 0ffffh?
2533:15902+10	AF35  CA94AF  		JZ	FNDNXT6	;yes, exit now then.
2534:15912+16	AF38  2AD9B5  		LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2535:15928+4	AF3B  EB      		XCHG
2536:15932+7	AF3C  1A      		LDAX	D
2537:15939+7	AF3D  FEE5    		CPI	0E5H	;empty directory entry?
2538:15946+10	AF3F  CA4AAF  		JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2539:15956+11	AF42  D5      		PUSH	D
2540:15967+17	AF43  CD7FAD  		CALL	MOREFLS	;more files in directory?
2541:15984+10	AF46  D1      		POP	D
2542:15994+10	AF47  D294AF  		JNC	FNDNXT6	;no more. Exit now.
2543:16004+17	AF4A  CD5EAD  	FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
2544:16021+13	AF4D  3AD8B5  		LDA	COUNTER	;get number of bytes (characters) to check.
2545:16034+5	AF50  4F      		MOV	C,A
2546:16039+7	AF51  0600    		MVI	B,0	;initialize byte position counter.
2547:16046+5	AF53  79      	FNDNXT2	MOV	A,C	;are we done with the compare?
2548:16051+4	AF54  B7      		ORA	A
2549:16055+10	AF55  CA83AF  		JZ	FNDNXT5
2550:16065+7	AF58  1A      		LDAX	D	;no, check next byte.
2551:16072+7	AF59  FE3F    		CPI	'?'	;don't care about this character?
2552:16079+10	AF5B  CA7CAF  		JZ	FNDNXT4
2553:16089+5	AF5E  78      		MOV	A,B	;get bytes position in fcb.
2554:16094+7	AF5F  FE0D    		CPI	13	;don't care about the thirteenth byte either.
2555:16101+10	AF61  CA7CAF  		JZ	FNDNXT4
2556:16111+7	AF64  FE0C    		CPI	12	;extent byte?
2557:16118+7	AF66  1A      		LDAX	D
2558:16125+10	AF67  CA73AF  		JZ	FNDNXT3
2559:16135+7	AF6A  96      		SUB	M	;otherwise compare characters.
2560:16142+7	AF6B  E67F    		ANI	7FH
2561:16149+10	AF6D  C22DAF  		JNZ	FINDNXT	;not the same, check next entry.
2562:16159+10	AF70  C37CAF  		JMP	FNDNXT4	;so far so good, keep checking.
2563:16169+11	AF73  C5      	FNDNXT3	PUSH	B	;check the extent byte here.
2564:16180+7	AF74  4E      		MOV	C,M
2565:16187+17	AF75  CD07AF  		CALL	SAMEXT
2566:16204+10	AF78  C1      		POP	B
2567:16214+10	AF79  C22DAF  		JNZ	FINDNXT	;not the same, look some more.
2568:				;
2569:				;   So far the names compare. Bump pointers to the next byte
2570:				; and continue until all (C) characters have been checked.
2571:				;
2572:16224+5	AF7C  13      	FNDNXT4	INX	D	;bump pointers.
2573:16229+5	AF7D  23      		INX	H
2574:16234+5	AF7E  04      		INR	B
2575:16239+5	AF7F  0D      		DCR	C	;adjust character counter.
2576:16244+10	AF80  C353AF  		JMP	FNDNXT2
2577:16254+13	AF83  3AEAB5  	FNDNXT5	LDA	FILEPOS	;return the position of this entry.
2578:16267+7	AF86  E603    		ANI	03H
2579:16274+13	AF88  3245AB  		STA	STATUS
2580:16287+10	AF8B  21D4B5  		LXI	H,FNDSTAT
2581:16297+7	AF8E  7E      		MOV	A,M
2582:16304+4	AF8F  17      		RAL
2583:16308+5+6	AF90  D0      		RNC
2584:16313+4	AF91  AF      		XRA	A
2585:16317+7	AF92  77      		MOV	M,A
2586:16324+10	AF93  C9      		RET
2587:				;
2588:				;   Filename was not found. Set appropriate status.
2589:				;
2590:16334+17	AF94  CDFEAD  	FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2591:16351+7	AF97  3EFF    		MVI	A,0FFH	;say not located.
2592:16358+10	AF99  C301AB  		JMP	SETSTAT
2593:				;
2594:				;   Erase files from the directory. Only the first byte of the
2595:				; fcb will be affected. It is set to (E5).
2596:				;
2597:16368+17	AF9C  CD54AD  	ERAFILE	CALL	CHKWPRT	;is disk write protected?
2598:16385+7	AF9F  0E0C    		MVI	C,12	;only compare file names.
2599:16392+17	AFA1  CD18AF  		CALL	FINDFST	;get first file name.
2600:16409+17	AFA4  CDF5AD  	ERAFIL1	CALL	CKFILPOS;any found?
2601:16426+5+6	AFA7  C8      		RZ		;nope, we must be done.
2602:16431+17	AFA8  CD44AD  		CALL	CHKROFL	;is file read only?
2603:16448+17	AFAB  CD5EAD  		CALL	FCB2HL	;nope, get address of fcb and
2604:16465+10	AFAE  36E5    		MVI	M,0E5H	;set first byte to 'empty'.
2605:16475+7	AFB0  0E00    		MVI	C,0	;clear the space from the bit map.
2606:16482+17	AFB2  CD6BAE  		CALL	SETFILE
2607:16499+17	AFB5  CDC6AD  		CALL	DIRWRITE;now write the directory sector back out.
2608:16516+17	AFB8  CD2DAF  		CALL	FINDNXT	;find the next file name.
2609:16533+10	AFBB  C3A4AF  		JMP	ERAFIL1	;and repeat process.
2610:				;
2611:				;   Look through the space allocation map (bit map) for the
2612:				; next available block. Start searching at block number (BC-1).
2613:				; The search procedure is to look for an empty block that is
2614:				; before the starting block. If not empty, look at a later
2615:				; block number. In this way, we return the closest empty block
2616:				; on either side of the 'target' block number. This will speed
2617:				; access on random devices. For serial devices, this should be
2618:				; changed to look in the forward direction first and then start
2619:				; at the front and search some more.
2620:				;
2621:				;   On return, (DE)= block number that is empty and (HL) =0
2622:				; if no empry block was found.
2623:				;
2624:16543+5	AFBE  50      	FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
2625:16548+5	AFBF  59      		MOV	E,C
2626:				;
2627:				;   Look before target block. Registers (BC) are used as the lower
2628:				; pointer and (DE) as the upper pointer.
2629:				;
2630:16553+5	AFC0  79      	FNDSPA1	MOV	A,C	;is block 0 specified?
2631:16558+4	AFC1  B0      		ORA	B
2632:16562+10	AFC2  CAD1AF  		JZ	FNDSPA2
2633:16572+5	AFC5  0B      		DCX	B	;nope, check previous block.
2634:16577+11	AFC6  D5      		PUSH	D
2635:16588+11	AFC7  C5      		PUSH	B
2636:16599+17	AFC8  CD35AE  		CALL	CKBITMAP
2637:16616+4	AFCB  1F      		RAR		;is this block empty?
2638:16620+10	AFCC  D2ECAF  		JNC	FNDSPA3	;yes. use this.
2639:				;
2640:				;   Note that the above logic gets the first block that it finds
2641:				; that is empty. Thus a file could be written 'backward' making
2642:				; it very slow to access. This could be changed to look for the
2643:				; first empty block and then continue until the start of this
2644:				; empty space is located and then used that starting block.
2645:				; This should help speed up access to some files especially on
2646:				; a well used disk with lots of fairly small 'holes'.
2647:				;
2648:16630+10	AFCF  C1      		POP	B	;nope, check some more.
2649:16640+10	AFD0  D1      		POP	D
2650:				;
2651:				;   Now look after target block.
2652:				;
2653:16650+16	AFD1  2AC6B5  	FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
2654:16666+5	AFD4  7B      		MOV	A,E
2655:16671+4	AFD5  95      		SUB	L
2656:16675+5	AFD6  7A      		MOV	A,D
2657:16680+4	AFD7  9C      		SBB	H
2658:16684+10	AFD8  D2F4AF  		JNC	FNDSPA4
2659:16694+5	AFDB  13      		INX	D	;yes, move on to next one.
2660:16699+11	AFDC  C5      		PUSH	B
2661:16710+11	AFDD  D5      		PUSH	D
2662:16721+5	AFDE  42      		MOV	B,D
2663:16726+5	AFDF  4B      		MOV	C,E
2664:16731+17	AFE0  CD35AE  		CALL	CKBITMAP;check it.
2665:16748+4	AFE3  1F      		RAR		;empty?
2666:16752+10	AFE4  D2ECAF  		JNC	FNDSPA3
2667:16762+10	AFE7  D1      		POP	D	;nope, continue searching.
2668:16772+10	AFE8  C1      		POP	B
2669:16782+10	AFE9  C3C0AF  		JMP	FNDSPA1
2670:				;
2671:				;   Empty block found. Set it as used and return with (HL)
2672:				; pointing to it (true?).
2673:				;
2674:16792+4	AFEC  17      	FNDSPA3	RAL		;reset byte.
2675:16796+5	AFED  3C      		INR	A	;and set bit 0.
2676:16801+17	AFEE  CD64AE  		CALL	STBMAP1	;update bit map.
2677:16818+10	AFF1  E1      		POP	H	;set return registers.
2678:16828+10	AFF2  D1      		POP	D
2679:16838+10	AFF3  C9      		RET
2680:				;
2681:				;   Free block was not found. If (BC) is not zero, then we have
2682:				; not checked all of the disk space.
2683:				;
2684:16848+5	AFF4  79      	FNDSPA4	MOV	A,C
2685:16853+4	AFF5  B0      		ORA	B
2686:16857+10	AFF6  C2C0AF  		JNZ	FNDSPA1
2687:16867+10	AFF9  210000  		LXI	H,0	;set 'not found' status.
2688:16877+10	AFFC  C9      		RET
2689:				;
2690:				;   Move a complete fcb entry into the directory and write it.
2691:				;
2692:16887+7	AFFD  0E00    	FCBSET	MVI	C,0
2693:16894+7	AFFF  1E20    		MVI	E,32	;length of each entry.
2694:				;
2695:				;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2696:				; fcb in directory starting at relative byte (C). This updated
2697:				; directory buffer is then written to the disk.
2698:				;
2699:16901+11	B001  D5      	UPDATE	PUSH	D
2700:16912+7	B002  0600    		MVI	B,0	;set (BC) to relative byte position.
2701:16919+16	B004  2A43AB  		LHLD	PARAMS	;get address of fcb.
2702:16935+10	B007  09      		DAD	B	;compute starting byte.
2703:16945+4	B008  EB      		XCHG
2704:16949+17	B009  CD5EAD  		CALL	FCB2HL	;get address of fcb to update in directory.
2705:16966+10	B00C  C1      		POP	B	;set (C) to number of bytes to change.
2706:16976+17	B00D  CD4FAB  		CALL	DE2HL
2707:16993+17	B010  CDC3AB  	UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
2708:17010+10	B013  C3C6AD  		JMP	DIRWRITE	;then write this sector out.
2709:				;
2710:				;   Routine to change the name of all files on the disk with a
2711:				; specified name. The fcb contains the current name as the
2712:				; first 12 characters and the new name 16 bytes into the fcb.
2713:				;
2714:17020+17	B016  CD54AD  	CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
2715:17037+7	B019  0E0C    		MVI	C,12	;match first 12 bytes of fcb only.
2716:17044+17	B01B  CD18AF  		CALL	FINDFST	;get first name.
2717:17061+16	B01E  2A43AB  		LHLD	PARAMS	;get address of fcb.
2718:17077+7	B021  7E      		MOV	A,M	;get user number.
2719:17084+10	B022  111000  		LXI	D,16	;move over to desired name.
2720:17094+10	B025  19      		DAD	D
2721:17104+7	B026  77      		MOV	M,A	;keep same user number.
2722:17111+17	B027  CDF5AD  	CHGNAM1	CALL	CKFILPOS;any matching file found?
2723:17128+5+6	B02A  C8      		RZ		;no, we must be done.
2724:17133+17	B02B  CD44AD  		CALL	CHKROFL	;check for read only file.
2725:17150+7	B02E  0E10    		MVI	C,16	;start 16 bytes into fcb.
2726:17157+7	B030  1E0C    		MVI	E,12	;and update the first 12 bytes of directory.
2727:17164+17	B032  CD01B0  		CALL	UPDATE
2728:17181+17	B035  CD2DAF  		CALL	FINDNXT	;get te next file name.
2729:17198+10	B038  C327B0  		JMP	CHGNAM1	;and continue.
2730:				;
2731:				;   Update a files attributes. The procedure is to search for
2732:				; every file with the same name as shown in fcb (ignoring bit 7)
2733:				; and then to update it (which includes bit 7). No other changes
2734:				; are made.
2735:				;
2736:17208+7	B03B  0E0C    	SAVEATTR:MVI	C,12	;match first 12 bytes.
2737:17215+17	B03D  CD18AF  		CALL	FINDFST	;look for first filename.
2738:17232+17	B040  CDF5AD  	SAVATR1	CALL	CKFILPOS;was one found?
2739:17249+5+6	B043  C8      		RZ		;nope, we must be done.
2740:17254+7	B044  0E00    		MVI	C,0	;yes, update the first 12 bytes now.
2741:17261+7	B046  1E0C    		MVI	E,12
2742:17268+17	B048  CD01B0  		CALL	UPDATE	;update filename and write directory.
2743:17285+17	B04B  CD2DAF  		CALL	FINDNXT	;and get the next file.
2744:17302+10	B04E  C340B0  		JMP	SAVATR1	;then continue until done.
2745:				;
2746:				;  Open a file (name specified in fcb).
2747:				;
2748:17312+7	B051  0E0F    	OPENIT	MVI	C,15	;compare the first 15 bytes.
2749:17319+17	B053  CD18AF  		CALL	FINDFST	;get the first one in directory.
2750:17336+17	B056  CDF5AD  		CALL	CKFILPOS;any at all?
2751:17353+5+6	B059  C8      		RZ
2752:17358+17	B05A  CDA6AC  	OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
2753:17375+7	B05D  7E      		MOV	A,M	;and get it.
2754:17382+11	B05E  F5      		PUSH	PSW	;save it and address.
2755:17393+11	B05F  E5      		PUSH	H
2756:17404+17	B060  CD5EAD  		CALL	FCB2HL	;point to fcb in directory.
2757:17421+4	B063  EB      		XCHG
2758:17425+16	B064  2A43AB  		LHLD	PARAMS	;this is the users copy.
2759:17441+7	B067  0E20    		MVI	C,32	;move it into users space.
2760:17448+11	B069  D5      		PUSH	D
2761:17459+17	B06A  CD4FAB  		CALL	DE2HL
2762:17476+17	B06D  CD78AD  		CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
2763:17493+10	B070  D1      		POP	D	;now get the extent byte from this fcb.
2764:17503+10	B071  210C00  		LXI	H,12
2765:17513+10	B074  19      		DAD	D
2766:17523+7	B075  4E      		MOV	C,M	;into (C).
2767:17530+10	B076  210F00  		LXI	H,15	;now get the record count byte into (B).
2768:17540+10	B079  19      		DAD	D
2769:17550+7	B07A  46      		MOV	B,M
2770:17557+10	B07B  E1      		POP	H	;keep the same extent as the user had originally.
2771:17567+10	B07C  F1      		POP	PSW
2772:17577+7	B07D  77      		MOV	M,A
2773:17584+5	B07E  79      		MOV	A,C	;is it the same as in the directory fcb?
2774:17589+7	B07F  BE      		CMP	M
2775:17596+5	B080  78      		MOV	A,B	;if yes, then use the same record count.
2776:17601+10	B081  CA8BB0  		JZ	OPENIT2
2777:17611+7	B084  3E00    		MVI	A,0	;if the user specified an extent greater than
2778:17618+10	B086  DA8BB0  		JC	OPENIT2	;the one in the directory, then set record count to 0.
2779:17628+7	B089  3E80    		MVI	A,128	;otherwise set to maximum.
2780:17635+16	B08B  2A43AB  	OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
2781:17651+10	B08E  110F00  		LXI	D,15
2782:17661+10	B091  19      		DAD	D	;compute relative position.
2783:17671+7	B092  77      		MOV	M,A	;and set the record count.
2784:17678+10	B093  C9      		RET
2785:				;
2786:				;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2787:				; point to a zero value (16 bit).
2788:				;   Return with zero flag set it (DE) was moved. Registers (DE)
2789:				; and (HL) are not changed. However (A) is.
2790:				;
2791:17688+7	B094  7E      	MOVEWORD:MOV	A,M	;check for a zero word.
2792:17695+5	B095  23      		INX	H
2793:17700+7	B096  B6      		ORA	M	;both bytes zero?
2794:17707+5	B097  2B      		DCX	H
2795:17712+5+6	B098  C0      		RNZ		;nope, just return.
2796:17717+7	B099  1A      		LDAX	D	;yes, move two bytes from (DE) into
2797:17724+7	B09A  77      		MOV	M,A	;this zero space.
2798:17731+5	B09B  13      		INX	D
2799:17736+5	B09C  23      		INX	H
2800:17741+7	B09D  1A      		LDAX	D
2801:17748+7	B09E  77      		MOV	M,A
2802:17755+5	B09F  1B      		DCX	D	;don't disturb these registers.
2803:17760+5	B0A0  2B      		DCX	H
2804:17765+10	B0A1  C9      		RET
2805:				;
2806:				;   Get here to close a file specified by (fcb).
2807:				;
2808:17775+4	B0A2  AF      	CLOSEIT	XRA	A	;clear status and file position bytes.
2809:17779+13	B0A3  3245AB  		STA	STATUS
2810:17792+13	B0A6  32EAB5  		STA	FILEPOS
2811:17805+13	B0A9  32EBB5  		STA	FILEPOS+1
2812:17818+17	B0AC  CD1EAD  		CALL	GETWPRT	;get write protect bit for this drive.
2813:17835+5+6	B0AF  C0      		RNZ		;just return if it is set.
2814:17840+17	B0B0  CD69AD  		CALL	GETS2	;else get the 's2' byte.
2815:17857+7	B0B3  E680    		ANI	80H	;and look at bit 7 (file unmodified?).
2816:17864+5+6	B0B5  C0      		RNZ		;just return if set.
2817:17869+7	B0B6  0E0F    		MVI	C,15	;else look up this file in directory.
2818:17876+17	B0B8  CD18AF  		CALL	FINDFST
2819:17893+17	B0BB  CDF5AD  		CALL	CKFILPOS;was it found?
2820:17910+5+6	B0BE  C8      		RZ		;just return if not.
2821:17915+10	B0BF  011000  		LXI	B,16	;set (HL) pointing to records used section.
2822:17925+17	B0C2  CD5EAD  		CALL	FCB2HL
2823:17942+10	B0C5  09      		DAD	B
2824:17952+4	B0C6  EB      		XCHG
2825:17956+16	B0C7  2A43AB  		LHLD	PARAMS	;do the same for users specified fcb.
2826:17972+10	B0CA  09      		DAD	B
2827:17982+7	B0CB  0E10    		MVI	C,16	;this many bytes are present in this extent.
2828:17989+13	B0CD  3ADDB5  	CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
2829:18002+4	B0D0  B7      		ORA	A
2830:18006+10	B0D1  CAE8B0  		JZ	CLOSEIT4
2831:18016+7	B0D4  7E      		MOV	A,M	;just 8 bit. Get one from users fcb.
2832:18023+4	B0D5  B7      		ORA	A
2833:18027+7	B0D6  1A      		LDAX	D	;now get one from directory fcb.
2834:18034+10	B0D7  C2DBB0  		JNZ	CLOSEIT2
2835:18044+7	B0DA  77      		MOV	M,A	;users byte was zero. Update from directory.
2836:18051+4	B0DB  B7      	CLOSEIT2:ORA	A
2837:18055+10	B0DC  C2E1B0  		JNZ	CLOSEIT3
2838:18065+7	B0DF  7E      		MOV	A,M	;directories byte was zero, update from users fcb.
2839:18072+7	B0E0  12      		STAX	D
2840:18079+7	B0E1  BE      	CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
2841:18086+10	B0E2  C21FB1  		JNZ	CLOSEIT7	;then close error if they are not the same.
2842:18096+10	B0E5  C3FDB0  		JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2843:18106+17	B0E8  CD94B0  	CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
2844:18123+4	B0EB  EB      		XCHG
2845:18127+17	B0EC  CD94B0  		CALL	MOVEWORD;update directories fcb if it is zero.
2846:18144+4	B0EF  EB      		XCHG
2847:18148+7	B0F0  1A      		LDAX	D	;if these two values are no different,
2848:18155+7	B0F1  BE      		CMP	M	;then a close error occured.
2849:18162+10	B0F2  C21FB1  		JNZ	CLOSEIT7
2850:18172+5	B0F5  13      		INX	D	;check second byte.
2851:18177+5	B0F6  23      		INX	H
2852:18182+7	B0F7  1A      		LDAX	D
2853:18189+7	B0F8  BE      		CMP	M
2854:18196+10	B0F9  C21FB1  		JNZ	CLOSEIT7
2855:18206+5	B0FC  0D      		DCR	C	;remember 16 bit values.
2856:18211+5	B0FD  13      	CLOSEIT5:INX	D	;bump to next item in table.
2857:18216+5	B0FE  23      		INX	H
2858:18221+5	B0FF  0D      		DCR	C	;there are 16 entries only.
2859:18226+10	B100  C2CDB0  		JNZ	CLOSEIT1;continue if more to do.
2860:18236+10	B103  01ECFF  		LXI	B,0FFECH;backup 20 places (extent byte).
2861:18246+10	B106  09      		DAD	B
2862:18256+4	B107  EB      		XCHG
2863:18260+10	B108  09      		DAD	B
2864:18270+7	B109  1A      		LDAX	D
2865:18277+7	B10A  BE      		CMP	M	;directory's extent already greater than the
2866:18284+10	B10B  DA17B1  		JC	CLOSEIT6	;users extent?
2867:18294+7	B10E  77      		MOV	M,A	;no, update directory extent.
2868:18301+10	B10F  010300  		LXI	B,3	;and update the record count byte in
2869:18311+10	B112  09      		DAD	B	;directories fcb.
2870:18321+4	B113  EB      		XCHG
2871:18325+10	B114  09      		DAD	B
2872:18335+7	B115  7E      		MOV	A,M	;get from user.
2873:18342+7	B116  12      		STAX	D	;and put in directory.
2874:18349+7	B117  3EFF    	CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
2875:18356+13	B119  32D2B5  		STA	CLOSEFLG
2876:18369+10	B11C  C310B0  		JMP	UPDATE1	;update the directory now.
2877:18379+10	B11F  2145AB  	CLOSEIT7:LXI	H,STATUS;set return status and then return.
2878:18389+10	B122  35      		DCR	M
2879:18399+10	B123  C9      		RET
2880:				;
2881:				;   Routine to get the next empty space in the directory. It
2882:				; will then be cleared for use.
2883:				;
2884:18409+17	B124  CD54AD  	GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
2885:18426+16	B127  2A43AB  		LHLD	PARAMS	;save current parameters (fcb).
2886:18442+11	B12A  E5      		PUSH	H
2887:18453+10	B12B  21ACB5  		LXI	H,EMPTYFCB;use special one for empty space.
2888:18463+16	B12E  2243AB  		SHLD	PARAMS
2889:18479+7	B131  0E01    		MVI	C,1	;search for first empty spot in directory.
2890:18486+17	B133  CD18AF  		CALL	FINDFST	;(* only check first byte *)
2891:18503+17	B136  CDF5AD  		CALL	CKFILPOS;none?
2892:18520+10	B139  E1      		POP	H
2893:18530+16	B13A  2243AB  		SHLD	PARAMS	;restore original fcb address.
2894:18546+5+6	B13D  C8      		RZ		;return if no more space.
2895:18551+4	B13E  EB      		XCHG
2896:18555+10	B13F  210F00  		LXI	H,15	;point to number of records for this file.
2897:18565+10	B142  19      		DAD	D
2898:18575+7	B143  0E11    		MVI	C,17	;and clear all of this space.
2899:18582+4	B145  AF      		XRA	A
2900:18586+7	B146  77      	GETMT1	MOV	M,A
2901:18593+5	B147  23      		INX	H
2902:18598+5	B148  0D      		DCR	C
2903:18603+10	B149  C246B1  		JNZ	GETMT1
2904:18613+10	B14C  210D00  		LXI	H,13	;clear the 's1' byte also.
2905:18623+10	B14F  19      		DAD	D
2906:18633+7	B150  77      		MOV	M,A
2907:18640+17	B151  CD8CAD  		CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
2908:18657+17	B154  CDFDAF  		CALL	FCBSET	;write out this fcb entry to directory.
2909:18674+10	B157  C378AD  		JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
2910:				;
2911:				;   Routine to close the current extent and open the next one
2912:				; for reading.
2913:				;
2914:18684+4	B15A  AF      	GETNEXT	XRA	A
2915:18688+13	B15B  32D2B5  		STA	CLOSEFLG;clear close flag.
2916:18701+17	B15E  CDA2B0  		CALL	CLOSEIT	;close this extent.
2917:18718+17	B161  CDF5AD  		CALL	CKFILPOS
2918:18735+5+6	B164  C8      		RZ		;not there???
2919:18740+16	B165  2A43AB  		LHLD	PARAMS	;get extent byte.
2920:18756+10	B168  010C00  		LXI	B,12
2921:18766+10	B16B  09      		DAD	B
2922:18776+7	B16C  7E      		MOV	A,M	;and increment it.
2923:18783+5	B16D  3C      		INR	A
2924:18788+7	B16E  E61F    		ANI	1FH	;keep within range 0-31.
2925:18795+7	B170  77      		MOV	M,A
2926:18802+10	B171  CA83B1  		JZ	GTNEXT1	;overflow?
2927:18812+5	B174  47      		MOV	B,A	;mask extent byte.
2928:18817+13	B175  3AC5B5  		LDA	EXTMASK
2929:18830+4	B178  A0      		ANA	B
2930:18834+10	B179  21D2B5  		LXI	H,CLOSEFLG;check close flag (0ffh is ok).
2931:18844+7	B17C  A6      		ANA	M
2932:18851+10	B17D  CA8EB1  		JZ	GTNEXT2	;if zero, we must read in next extent.
2933:18861+10	B180  C3ACB1  		JMP	GTNEXT3	;else, it is already in memory.
2934:18871+10	B183  010200  	GTNEXT1	LXI	B,2	;Point to the 's2' byte.
2935:18881+10	B186  09      		DAD	B
2936:18891+10	B187  34      		INR	M	;and bump it.
2937:18901+7	B188  7E      		MOV	A,M	;too many extents?
2938:18908+7	B189  E60F    		ANI	0FH
2939:18915+10	B18B  CAB6B1  		JZ	GTNEXT5	;yes, set error code.
2940:				;
2941:				;   Get here to open the next extent.
2942:				;
2943:18925+7	B18E  0E0F    	GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
2944:18932+17	B190  CD18AF  		CALL	FINDFST	;find the first one.
2945:18949+17	B193  CDF5AD  		CALL	CKFILPOS;none available?
2946:18966+10	B196  C2ACB1  		JNZ	GTNEXT3
2947:18976+13	B199  3AD3B5  		LDA	RDWRTFLG;no extent present. Can we open an empty one?
2948:18989+5	B19C  3C      		INR	A	;0ffh means reading (so not possible).
2949:18994+10	B19D  CAB6B1  		JZ	GTNEXT5	;or an error.
2950:19004+17	B1A0  CD24B1  		CALL	GETEMPTY;we are writing, get an empty entry.
2951:19021+17	B1A3  CDF5AD  		CALL	CKFILPOS;none?
2952:19038+10	B1A6  CAB6B1  		JZ	GTNEXT5	;error if true.
2953:19048+10	B1A9  C3AFB1  		JMP	GTNEXT4	;else we are almost done.
2954:19058+17	B1AC  CD5AB0  	GTNEXT3	CALL	OPENIT1	;open this extent.
2955:19075+17	B1AF  CDBBAC  	GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
2956:19092+4	B1B2  AF      		XRA	A	;clear status and return.
2957:19096+10	B1B3  C301AB  		JMP	SETSTAT
2958:				;
2959:				;   Error in extending the file. Too many extents were needed
2960:				; or not enough space on the disk.
2961:				;
2962:19106+17	B1B6  CD05AB  	GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
2963:19123+10	B1B9  C378AD  		JMP	SETS2B7	;so this is not written on a close.
2964:				;
2965:				;   Read a sequential file.
2966:				;
2967:19133+7	B1BC  3E01    	RDSEQ	MVI	A,1	;set sequential access mode.
2968:19140+13	B1BE  32D5B5  		STA	MODE
2969:19153+7	B1C1  3EFF    	RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
2970:19160+13	B1C3  32D3B5  		STA	RDWRTFLG
2971:19173+17	B1C6  CDBBAC  		CALL	STRDATA	;put rec# and ext# into fcb.
2972:19190+13	B1C9  3AE3B5  		LDA	SAVNREC	;get next record to read.
2973:19203+10	B1CC  21E1B5  		LXI	H,SAVNXT;get number of records in extent.
2974:19213+7	B1CF  BE      		CMP	M	;within this extent?
2975:19220+10	B1D0  DAE6B1  		JC	RDSEQ2
2976:19230+7	B1D3  FE80    		CPI	128	;no. Is this extent fully used?
2977:19237+10	B1D5  C2FBB1  		JNZ	RDSEQ3	;no. End-of-file.
2978:19247+17	B1D8  CD5AB1  		CALL	GETNEXT	;yes, open the next one.
2979:19264+4	B1DB  AF      		XRA	A	;reset next record to read.
2980:19268+13	B1DC  32E3B5  		STA	SAVNREC
2981:19281+13	B1DF  3A45AB  		LDA	STATUS	;check on open, successful?
2982:19294+4	B1E2  B7      		ORA	A
2983:19298+10	B1E3  C2FBB1  		JNZ	RDSEQ3	;no, error.
2984:19308+17	B1E6  CD77AC  	RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
2985:19325+17	B1E9  CD84AC  		CALL	CHKBLK	;check it. Within bounds?
2986:19342+10	B1EC  CAFBB1  		JZ	RDSEQ3	;no, error.
2987:19352+17	B1EF  CD8AAC  		CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
2988:19369+17	B1F2  CDD1AB  		CALL	TRKSEC1	;set the track and sector for this block #.
2989:19386+17	B1F5  CDB2AB  		CALL	DOREAD	;and read it.
2990:19403+10	B1F8  C3D2AC  		JMP	SETNREC	;and set the next record to be accessed.
2991:				;
2992:				;   Read error occured. Set status and return.
2993:				;
2994:19413+10	B1FB  C305AB  	RDSEQ3	JMP	IOERR1
2995:				;
2996:				;   Write the next sequential record.
2997:				;
2998:19423+7	B1FE  3E01    	WTSEQ	MVI	A,1	;set sequential access mode.
2999:19430+13	B200  32D5B5  		STA	MODE
3000:19443+7	B203  3E00    	WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
3001:19450+13	B205  32D3B5  		STA	RDWRTFLG
3002:19463+17	B208  CD54AD  		CALL	CHKWPRT	;check write protect status.
3003:19480+16	B20B  2A43AB  		LHLD	PARAMS
3004:19496+17	B20E  CD47AD  		CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3005:19513+17	B211  CDBBAC  		CALL	STRDATA	;put updated data into fcb.
3006:19530+13	B214  3AE3B5  		LDA	SAVNREC	;get record number to write.
3007:19543+7	B217  FE80    		CPI	128	;within range?
3008:19550+10	B219  D205AB  		JNC	IOERR1	;no, error(?).
3009:19560+17	B21C  CD77AC  		CALL	COMBLK	;compute block number.
3010:19577+17	B21F  CD84AC  		CALL	CHKBLK	;check number.
3011:19594+7	B222  0E00    		MVI	C,0	;is there one to write to?
3012:19601+10	B224  C26EB2  		JNZ	WTSEQ6	;yes, go do it.
3013:19611+17	B227  CD3EAC  		CALL	GETBLOCK;get next block number within fcb to use.
3014:19628+13	B22A  32D7B5  		STA	RELBLOCK;and save.
3015:19641+10	B22D  010000  		LXI	B,0	;start looking for space from the start
3016:19651+4	B230  B7      		ORA	A	;if none allocated as yet.
3017:19655+10	B231  CA3BB2  		JZ	WTSEQ2
3018:19665+5	B234  4F      		MOV	C,A	;extract previous block number from fcb
3019:19670+5	B235  0B      		DCX	B	;so we can be closest to it.
3020:19675+17	B236  CD5EAC  		CALL	EXTBLK
3021:19692+5	B239  44      		MOV	B,H
3022:19697+5	B23A  4D      		MOV	C,L
3023:19702+17	B23B  CDBEAF  	WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
3024:19719+5	B23E  7D      		MOV	A,L	;check for a zero number.
3025:19724+4	B23F  B4      		ORA	H
3026:19728+10	B240  C248B2  		JNZ	WTSEQ3
3027:19738+7	B243  3E02    		MVI	A,2	;no more space?
3028:19745+10	B245  C301AB  		JMP	SETSTAT
3029:19755+16	B248  22E5B5  	WTSEQ3	SHLD	BLKNMBR	;save block number to access.
3030:19771+4	B24B  EB      		XCHG		;put block number into (DE).
3031:19775+16	B24C  2A43AB  		LHLD	PARAMS	;now we must update the fcb for this
3032:19791+10	B24F  011000  		LXI	B,16	;newly allocated block.
3033:19801+10	B252  09      		DAD	B
3034:19811+13	B253  3ADDB5  		LDA	BIGDISK	;8 or 16 bit block numbers?
3035:19824+4	B256  B7      		ORA	A
3036:19828+13	B257  3AD7B5  		LDA	RELBLOCK	;(* update this entry *)
3037:19841+10	B25A  CA64B2  		JZ	WTSEQ4	;zero means 16 bit ones.
3038:19851+17	B25D  CD64AD  		CALL	ADDA2HL	;(HL)=(HL)+(A)
3039:19868+7	B260  73      		MOV	M,E	;store new block number.
3040:19875+10	B261  C36CB2  		JMP	WTSEQ5
3041:19885+5	B264  4F      	WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
3042:19890+7	B265  0600    		MVI	B,0
3043:19897+10	B267  09      		DAD	B
3044:19907+10	B268  09      		DAD	B
3045:19917+7	B269  73      		MOV	M,E	;stuff block number (DE) there.
3046:19924+5	B26A  23      		INX	H
3047:19929+7	B26B  72      		MOV	M,D
3048:19936+7	B26C  0E02    	WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3049:19943+13	B26E  3A45AB  	WTSEQ6	LDA	STATUS	;are we ok so far?
3050:19956+4	B271  B7      		ORA	A
3051:19960+5+6	B272  C0      		RNZ
3052:19965+11	B273  C5      		PUSH	B	;yes, save write flag for bios (register C).
3053:19976+17	B274  CD8AAC  		CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3054:19993+13	B277  3AD5B5  		LDA	MODE	;get access mode flag (1=sequential,
3055:20006+5	B27A  3D      		DCR	A	;0=random, 2=special?).
3056:20011+5	B27B  3D      		DCR	A
3057:20016+10	B27C  C2BBB2  		JNZ	WTSEQ9
3058:				;
3059:				;   Special random i/o from function #40. Maybe for M/PM, but the
3060:				; current block, if it has not been written to, will be zeroed
3061:				; out and then written (reason?).
3062:				;
3063:20026+10	B27F  C1      		POP	B
3064:20036+11	B280  C5      		PUSH	B
3065:20047+5	B281  79      		MOV	A,C	;get write status flag (2=writing unused space).
3066:20052+5	B282  3D      		DCR	A
3067:20057+5	B283  3D      		DCR	A
3068:20062+10	B284  C2BBB2  		JNZ	WTSEQ9
3069:20072+11	B287  E5      		PUSH	H
3070:20083+16	B288  2AB9B5  		LHLD	DIRBUF	;zero out the directory buffer.
3071:20099+5	B28B  57      		MOV	D,A	;note that (A) is zero here.
3072:20104+7	B28C  77      	WTSEQ7	MOV	M,A
3073:20111+5	B28D  23      		INX	H
3074:20116+5	B28E  14      		INR	D	;do 128 bytes.
3075:20121+10	B28F  F28CB2  		JP	WTSEQ7
3076:20131+17	B292  CDE0AD  		CALL	DIRDMA	;tell the bios the dma address for directory access.
3077:20148+16	B295  2AE7B5  		LHLD	LOGSECT	;get sector that starts current block.
3078:20164+7	B298  0E02    		MVI	C,2	;set 'writing to unused space' flag.
3079:20171+16	B29A  22E5B5  	WTSEQ8	SHLD	BLKNMBR	;save sector to write.
3080:20187+11	B29D  C5      		PUSH	B
3081:20198+17	B29E  CDD1AB  		CALL	TRKSEC1	;determine its track and sector numbers.
3082:20215+10	B2A1  C1      		POP	B
3083:20225+17	B2A2  CDB8AB  		CALL	DOWRITE	;now write out 128 bytes of zeros.
3084:20242+16	B2A5  2AE5B5  		LHLD	BLKNMBR	;get sector number.
3085:20258+7	B2A8  0E00    		MVI	C,0	;set normal write flag.
3086:20265+13	B2AA  3AC4B5  		LDA	BLKMASK	;determine if we have written the entire
3087:20278+5	B2AD  47      		MOV	B,A	;physical block.
3088:20283+4	B2AE  A5      		ANA	L
3089:20287+4	B2AF  B8      		CMP	B
3090:20291+5	B2B0  23      		INX	H	;prepare for the next one.
3091:20296+10	B2B1  C29AB2  		JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3092:20306+10	B2B4  E1      		POP	H	;reset next sector number.
3093:20316+16	B2B5  22E5B5  		SHLD	BLKNMBR
3094:20332+17	B2B8  CDDAAD  		CALL	DEFDMA	;and reset dma address.
3095:				;
3096:				;   Normal disk write. Set the desired track and sector then
3097:				; do the actual write.
3098:				;
3099:20349+17	B2BB  CDD1AB  	WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
3100:20366+10	B2BE  C1      		POP	B	;get write status flag.
3101:20376+11	B2BF  C5      		PUSH	B
3102:20387+17	B2C0  CDB8AB  		CALL	DOWRITE	;and write this out.
3103:20404+10	B2C3  C1      		POP	B
3104:20414+13	B2C4  3AE3B5  		LDA	SAVNREC	;get number of records in file.
3105:20427+10	B2C7  21E1B5  		LXI	H,SAVNXT;get last record written.
3106:20437+7	B2CA  BE      		CMP	M
3107:20444+10	B2CB  DAD2B2  		JC	WTSEQ10
3108:20454+7	B2CE  77      		MOV	M,A	;we have to update record count.
3109:20461+10	B2CF  34      		INR	M
3110:20471+7	B2D0  0E02    		MVI	C,2
3111:				;
3112:				;*   This area has been patched to correct disk update problem
3113:				;* when using blocking and de-blocking in the BIOS.
3114:				;
3115:20478+4	B2D2  00      	WTSEQ10	NOP		;was 'dcr c'
3116:20482+4	B2D3  00      		NOP		;was 'dcr c'
3117:20486+10	B2D4  210000  		LXI	H,0	;was 'jnz wtseq99'
3118:				;
3119:				; *   End of patch.
3120:				;
3121:20496+11	B2D7  F5      		PUSH	PSW
3122:20507+17	B2D8  CD69AD  		CALL	GETS2	;set 'extent written to' flag.
3123:20524+7	B2DB  E67F    		ANI	7FH	;(* clear bit 7 *)
3124:20531+7	B2DD  77      		MOV	M,A
3125:20538+10	B2DE  F1      		POP	PSW	;get record count for this extent.
3126:20548+7	B2DF  FE7F    	WTSEQ99	CPI	127	;is it full?
3127:20555+10	B2E1  C200B3  		JNZ	WTSEQ12
3128:20565+13	B2E4  3AD5B5  		LDA	MODE	;yes, are we in sequential mode?
3129:20578+7	B2E7  FE01    		CPI	1
3130:20585+10	B2E9  C200B3  		JNZ	WTSEQ12
3131:20595+17	B2EC  CDD2AC  		CALL	SETNREC	;yes, set next record number.
3132:20612+17	B2EF  CD5AB1  		CALL	GETNEXT	;and get next empty space in directory.
3133:20629+10	B2F2  2145AB  		LXI	H,STATUS;ok?
3134:20639+7	B2F5  7E      		MOV	A,M
3135:20646+4	B2F6  B7      		ORA	A
3136:20650+10	B2F7  C2FEB2  		JNZ	WTSEQ11
3137:20660+5	B2FA  3D      		DCR	A	;yes, set record count to -1.
3138:20665+13	B2FB  32E3B5  		STA	SAVNREC
3139:20678+10	B2FE  3600    	WTSEQ11	MVI	M,0	;clear status.
3140:20688+10	B300  C3D2AC  	WTSEQ12	JMP	SETNREC	;set next record to access.
3141:				;
3142:				;   For random i/o, set the fcb for the desired record number
3143:				; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3144:				; used as follows:
3145:				;
3146:				;       fcb+35            fcb+34            fcb+33
3147:				;  |     'r-2'      |      'r-1'      |      'r-0'     |
3148:				;  |7             0 | 7             0 | 7             0|
3149:				;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3150:				;  |    overflow   | | extra |  extent   |   record #  |
3151:				;  | ______________| |_extent|__number___|_____________|
3152:				;                     also 's2'
3153:				;
3154:				;   On entry, register (C) contains 0ffh if this is a read
3155:				; and thus we can not access unwritten disk space. Otherwise,
3156:				; another extent will be opened (for writing) if required.
3157:				;
3158:20698+4	B303  AF      	POSITION:XRA	A	;set random i/o flag.
3159:20702+13	B304  32D5B5  		STA	MODE
3160:				;
3161:				;   Special entry (function #40). M/PM ?
3162:				;
3163:20715+11	B307  C5      	POSITN1	PUSH	B	;save read/write flag.
3164:20726+16	B308  2A43AB  		LHLD	PARAMS	;get address of fcb.
3165:20742+4	B30B  EB      		XCHG
3166:20746+10	B30C  212100  		LXI	H,33	;now get byte 'r0'.
3167:20756+10	B30F  19      		DAD	D
3168:20766+7	B310  7E      		MOV	A,M
3169:20773+7	B311  E67F    		ANI	7FH	;keep bits 0-6 for the record number to access.
3170:20780+11	B313  F5      		PUSH	PSW
3171:20791+7	B314  7E      		MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3172:20798+4	B315  17      		RAL
3173:20802+5	B316  23      		INX	H
3174:20807+7	B317  7E      		MOV	A,M
3175:20814+4	B318  17      		RAL
3176:20818+7	B319  E61F    		ANI	1FH	;and save this in bits 0-4 of (C).
3177:20825+5	B31B  4F      		MOV	C,A	;this is the extent byte.
3178:20830+7	B31C  7E      		MOV	A,M	;now get the extra extent byte.
3179:20837+4	B31D  1F      		RAR
3180:20841+4	B31E  1F      		RAR
3181:20845+4	B31F  1F      		RAR
3182:20849+4	B320  1F      		RAR
3183:20853+7	B321  E60F    		ANI	0FH
3184:20860+5	B323  47      		MOV	B,A	;and save it in (B).
3185:20865+10	B324  F1      		POP	PSW	;get record number back to (A).
3186:20875+5	B325  23      		INX	H	;check overflow byte 'r2'.
3187:20880+7	B326  6E      		MOV	L,M
3188:20887+5	B327  2C      		INR	L
3189:20892+5	B328  2D      		DCR	L
3190:20897+7	B329  2E06    		MVI	L,6	;prepare for error.
3191:20904+10	B32B  C28BB3  		JNZ	POSITN5	;out of disk space error.
3192:20914+10	B32E  212000  		LXI	H,32	;store record number into fcb.
3193:20924+10	B331  19      		DAD	D
3194:20934+7	B332  77      		MOV	M,A
3195:20941+10	B333  210C00  		LXI	H,12	;and now check the extent byte.
3196:20951+10	B336  19      		DAD	D
3197:20961+5	B337  79      		MOV	A,C
3198:20966+7	B338  96      		SUB	M	;same extent as before?
3199:20973+10	B339  C247B3  		JNZ	POSITN2
3200:20983+10	B33C  210E00  		LXI	H,14	;yes, check extra extent byte 's2' also.
3201:20993+10	B33F  19      		DAD	D
3202:21003+5	B340  78      		MOV	A,B
3203:21008+7	B341  96      		SUB	M
3204:21015+7	B342  E67F    		ANI	7FH
3205:21022+10	B344  CA7FB3  		JZ	POSITN3;same, we are almost done then.
3206:				;
3207:				;  Get here when another extent is required.
3208:				;
3209:21032+11	B347  C5      	POSITN2	PUSH	B
3210:21043+11	B348  D5      		PUSH	D
3211:21054+17	B349  CDA2B0  		CALL	CLOSEIT	;close current extent.
3212:21071+10	B34C  D1      		POP	D
3213:21081+10	B34D  C1      		POP	B
3214:21091+7	B34E  2E03    		MVI	L,3	;prepare for error.
3215:21098+13	B350  3A45AB  		LDA	STATUS
3216:21111+5	B353  3C      		INR	A
3217:21116+10	B354  CA84B3  		JZ	POSITN4	;close error.
3218:21126+10	B357  210C00  		LXI	H,12	;put desired extent into fcb now.
3219:21136+10	B35A  19      		DAD	D
3220:21146+7	B35B  71      		MOV	M,C
3221:21153+10	B35C  210E00  		LXI	H,14	;and store extra extent byte 's2'.
3222:21163+10	B35F  19      		DAD	D
3223:21173+7	B360  70      		MOV	M,B
3224:21180+17	B361  CD51B0  		CALL	OPENIT	;try and get this extent.
3225:21197+13	B364  3A45AB  		LDA	STATUS	;was it there?
3226:21210+5	B367  3C      		INR	A
3227:21215+10	B368  C27FB3  		JNZ	POSITN3
3228:21225+10	B36B  C1      		POP	B	;no. can we create a new one (writing?).
3229:21235+11	B36C  C5      		PUSH	B
3230:21246+7	B36D  2E04    		MVI	L,4	;prepare for error.
3231:21253+5	B36F  0C      		INR	C
3232:21258+10	B370  CA84B3  		JZ	POSITN4	;nope, reading unwritten space error.
3233:21268+17	B373  CD24B1  		CALL	GETEMPTY;yes we can, try to find space.
3234:21285+7	B376  2E05    		MVI	L,5	;prepare for error.
3235:21292+13	B378  3A45AB  		LDA	STATUS
3236:21305+5	B37B  3C      		INR	A
3237:21310+10	B37C  CA84B3  		JZ	POSITN4	;out of space?
3238:				;
3239:				;   Normal return location. Clear error code and return.
3240:				;
3241:21320+10	B37F  C1      	POSITN3	POP	B	;restore stack.
3242:21330+4	B380  AF      		XRA	A	;and clear error code byte.
3243:21334+10	B381  C301AB  		JMP	SETSTAT
3244:				;
3245:				;   Error. Set the 's2' byte to indicate this (why?).
3246:				;
3247:21344+11	B384  E5      	POSITN4	PUSH	H
3248:21355+17	B385  CD69AD  		CALL	GETS2
3249:21372+10	B388  36C0    		MVI	M,0C0H
3250:21382+10	B38A  E1      		POP	H
3251:				;
3252:				;   Return with error code (presently in L).
3253:				;
3254:21392+10	B38B  C1      	POSITN5	POP	B
3255:21402+5	B38C  7D      		MOV	A,L	;get error code.
3256:21407+13	B38D  3245AB  		STA	STATUS
3257:21420+10	B390  C378AD  		JMP	SETS2B7
3258:				;
3259:				;   Read a random record.
3260:				;
3261:21430+7	B393  0EFF    	READRAN	MVI	C,0FFH	;set 'read' status.
3262:21437+17	B395  CD03B3  		CALL	POSITION;position the file to proper record.
3263:21454+11+6	B398  CCC1B1  		CZ	RDSEQ1	;and read it as usual (if no errors).
3264:21465+10	B39B  C9      		RET
3265:				;
3266:				;   Write to a random record.
3267:				;
3268:21475+7	B39C  0E00    	WRITERAN:MVI	C,0	;set 'writing' flag.
3269:21482+17	B39E  CD03B3  		CALL	POSITION;position the file to proper record.
3270:21499+11+6	B3A1  CC03B2  		CZ	WTSEQ1	;and write as usual (if no errors).
3271:21510+10	B3A4  C9      		RET
3272:				;
3273:				;   Compute the random record number. Enter with (HL) pointing
3274:				; to a fcb an (DE) contains a relative location of a record
3275:				; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3276:				; byte, and (A) the 'r2' byte.
3277:				;
3278:				;   On return, the zero flag is set if the record is within
3279:				; bounds. Otherwise, an overflow occured.
3280:				;
3281:21520+4	B3A5  EB      	COMPRAND:XCHG		;save fcb pointer in (DE).
3282:21524+10	B3A6  19      		DAD	D	;compute relative position of record #.
3283:21534+7	B3A7  4E      		MOV	C,M	;get record number into (BC).
3284:21541+7	B3A8  0600    		MVI	B,0
3285:21548+10	B3AA  210C00  		LXI	H,12	;now get extent.
3286:21558+10	B3AD  19      		DAD	D
3287:21568+7	B3AE  7E      		MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3288:21575+4	B3AF  0F      		RRC		;move lower bit into bit 7.
3289:21579+7	B3B0  E680    		ANI	80H	;and ignore all other bits.
3290:21586+4	B3B2  81      		ADD	C	;add to our record number.
3291:21590+5	B3B3  4F      		MOV	C,A
3292:21595+7	B3B4  3E00    		MVI	A,0	;take care of any carry.
3293:21602+4	B3B6  88      		ADC	B
3294:21606+5	B3B7  47      		MOV	B,A
3295:21611+7	B3B8  7E      		MOV	A,M	;now get the upper bits of extent into
3296:21618+4	B3B9  0F      		RRC		;bit positions 0-3.
3297:21622+7	B3BA  E60F    		ANI	0FH	;and ignore all others.
3298:21629+4	B3BC  80      		ADD	B	;add this in to 'r1' byte.
3299:21633+5	B3BD  47      		MOV	B,A
3300:21638+10	B3BE  210E00  		LXI	H,14	;get the 's2' byte (extra extent).
3301:21648+10	B3C1  19      		DAD	D
3302:21658+7	B3C2  7E      		MOV	A,M
3303:21665+4	B3C3  87      		ADD	A	;and shift it left 4 bits (bits 4-7).
3304:21669+4	B3C4  87      		ADD	A
3305:21673+4	B3C5  87      		ADD	A
3306:21677+4	B3C6  87      		ADD	A
3307:21681+11	B3C7  F5      		PUSH	PSW	;save carry flag (bit 0 of flag byte).
3308:21692+4	B3C8  80      		ADD	B	;now add extra extent into 'r1'.
3309:21696+5	B3C9  47      		MOV	B,A
3310:21701+11	B3CA  F5      		PUSH	PSW	;and save carry (overflow byte 'r2').
3311:21712+10	B3CB  E1      		POP	H	;bit 0 of (L) is the overflow indicator.
3312:21722+5	B3CC  7D      		MOV	A,L
3313:21727+10	B3CD  E1      		POP	H	;and same for first carry flag.
3314:21737+4	B3CE  B5      		ORA	L	;either one of these set?
3315:21741+7	B3CF  E601    		ANI	01H	;only check the carry flags.
3316:21748+10	B3D1  C9      		RET
3317:				;
3318:				;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3319:				; reflect the last record used for a random (or other) file.
3320:				; This reads the directory and looks at all extents computing
3321:				; the largerst record number for each and keeping the maximum
3322:				; value only. Then 'r0', 'r1', and 'r2' will reflect this
3323:				; maximum record number. This is used to compute the space used
3324:				; by a random file.
3325:				;
3326:21758+7	B3D2  0E0C    	RANSIZE	MVI	C,12	;look thru directory for first entry with
3327:21765+17	B3D4  CD18AF  		CALL	FINDFST	;this name.
3328:21782+16	B3D7  2A43AB  		LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
3329:21798+10	B3DA  112100  		LXI	D,33
3330:21808+10	B3DD  19      		DAD	D
3331:21818+11	B3DE  E5      		PUSH	H
3332:21829+7	B3DF  72      		MOV	M,D	;note that (D)=0.
3333:21836+5	B3E0  23      		INX	H
3334:21841+7	B3E1  72      		MOV	M,D
3335:21848+5	B3E2  23      		INX	H
3336:21853+7	B3E3  72      		MOV	M,D
3337:21860+17	B3E4  CDF5AD  	RANSIZ1	CALL	CKFILPOS;is there an extent to process?
3338:21877+10	B3E7  CA0CB4  		JZ	RANSIZ3	;no, we are done.
3339:21887+17	B3EA  CD5EAD  		CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3340:21904+10	B3ED  110F00  		LXI	D,15	;point to last record in extent.
3341:21914+17	B3F0  CDA5B3  		CALL	COMPRAND;and compute random parameters.
3342:21931+10	B3F3  E1      		POP	H
3343:21941+11	B3F4  E5      		PUSH	H	;now check these values against those
3344:21952+5	B3F5  5F      		MOV	E,A	;already in fcb.
3345:21957+5	B3F6  79      		MOV	A,C	;the carry flag will be set if those
3346:21962+7	B3F7  96      		SUB	M	;in the fcb represent a larger size than
3347:21969+5	B3F8  23      		INX	H	;this extent does.
3348:21974+5	B3F9  78      		MOV	A,B
3349:21979+7	B3FA  9E      		SBB	M
3350:21986+5	B3FB  23      		INX	H
3351:21991+5	B3FC  7B      		MOV	A,E
3352:21996+7	B3FD  9E      		SBB	M
3353:22003+10	B3FE  DA06B4  		JC	RANSIZ2
3354:22013+7	B401  73      		MOV	M,E	;we found a larger (in size) extent.
3355:22020+5	B402  2B      		DCX	H	;stuff these values into fcb.
3356:22025+7	B403  70      		MOV	M,B
3357:22032+5	B404  2B      		DCX	H
3358:22037+7	B405  71      		MOV	M,C
3359:22044+17	B406  CD2DAF  	RANSIZ2	CALL	FINDNXT	;now get the next extent.
3360:22061+10	B409  C3E4B3  		JMP	RANSIZ1	;continue til all done.
3361:22071+10	B40C  E1      	RANSIZ3	POP	H	;we are done, restore the stack and
3362:22081+10	B40D  C9      		RET		;return.
3363:				;
3364:				;   Function to return the random record position of a given
3365:				; file which has been read in sequential mode up to now.
3366:				;
3367:22091+16	B40E  2A43AB  	SETRAN	LHLD	PARAMS	;point to fcb.
3368:22107+10	B411  112000  		LXI	D,32	;and to last used record.
3369:22117+17	B414  CDA5B3  		CALL	COMPRAND;compute random position.
3370:22134+10	B417  212100  		LXI	H,33	;now stuff these values into fcb.
3371:22144+10	B41A  19      		DAD	D
3372:22154+7	B41B  71      		MOV	M,C	;move 'r0'.
3373:22161+5	B41C  23      		INX	H
3374:22166+7	B41D  70      		MOV	M,B	;and 'r1'.
3375:22173+5	B41E  23      		INX	H
3376:22178+7	B41F  77      		MOV	M,A	;and lastly 'r2'.
3377:22185+10	B420  C9      		RET
3378:				;
3379:				;   This routine select the drive specified in (ACTIVE) and
3380:				; update the login vector and bitmap table if this drive was
3381:				; not already active.
3382:				;
3383:22195+16	B421  2AAFB5  	LOGINDRV:LHLD	LOGIN	;get the login vector.
3384:22211+13	B424  3A42AB  		LDA	ACTIVE	;get the default drive.
3385:22224+5	B427  4F      		MOV	C,A
3386:22229+17	B428  CDEAAC  		CALL	SHIFTR	;position active bit for this drive
3387:22246+11	B42B  E5      		PUSH	H	;into bit 0.
3388:22257+4	B42C  EB      		XCHG
3389:22261+17	B42D  CD59AB  		CALL	SELECT	;select this drive.
3390:22278+10	B430  E1      		POP	H
3391:22288+11+6	B431  CC47AB  		CZ	SLCTERR	;valid drive?
3392:22299+5	B434  7D      		MOV	A,L	;is this a newly activated drive?
3393:22304+4	B435  1F      		RAR
3394:22308+5+6	B436  D8      		RC
3395:22313+16	B437  2AAFB5  		LHLD	LOGIN	;yes, update the login vector.
3396:22329+5	B43A  4D      		MOV	C,L
3397:22334+5	B43B  44      		MOV	B,H
3398:22339+17	B43C  CD0BAD  		CALL	SETBIT
3399:22356+16	B43F  22AFB5  		SHLD	LOGIN	;and save.
3400:22372+10	B442  C3A3AE  		JMP	BITMAP	;now update the bitmap.
3401:				;
3402:				;   Function to set the active disk number.
3403:				;
3404:22382+13	B445  3AD6B5  	SETDSK	LDA	EPARAM	;get parameter passed and see if this
3405:22395+10	B448  2142AB  		LXI	H,ACTIVE;represents a change in drives.
3406:22405+7	B44B  BE      		CMP	M
3407:22412+5+6	B44C  C8      		RZ
3408:22417+7	B44D  77      		MOV	M,A	;yes it does, log it in.
3409:22424+10	B44E  C321B4  		JMP	LOGINDRV
3410:				;
3411:				;   This is the 'auto disk select' routine. The firsst byte
3412:				; of the fcb is examined for a drive specification. If non
3413:				; zero then the drive will be selected and loged in.
3414:				;
3415:22434+7	B451  3EFF    	AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
3416:22441+13	B453  32DEB5  		STA	AUTO
3417:22454+16	B456  2A43AB  		LHLD	PARAMS	;get drive specified.
3418:22470+7	B459  7E      		MOV	A,M
3419:22477+7	B45A  E61F    		ANI	1FH	;look at lower 5 bits.
3420:22484+5	B45C  3D      		DCR	A	;adjust for (1=A, 2=B) etc.
3421:22489+13	B45D  32D6B5  		STA	EPARAM	;and save for the select routine.
3422:22502+7	B460  FE1E    		CPI	1EH	;check for 'no change' condition.
3423:22509+10	B462  D275B4  		JNC	AUTOSL1	;yes, don't change.
3424:22519+13	B465  3A42AB  		LDA	ACTIVE	;we must change, save currently active
3425:22532+13	B468  32DFB5  		STA	OLDDRV	;drive.
3426:22545+7	B46B  7E      		MOV	A,M	;and save first byte of fcb also.
3427:22552+13	B46C  32E0B5  		STA	AUTOFLAG;this must be non-zero.
3428:22565+7	B46F  E6E0    		ANI	0E0H	;whats this for (bits 6,7 are used for
3429:22572+7	B471  77      		MOV	M,A	;something)?
3430:22579+17	B472  CD45B4  		CALL	SETDSK	;select and log in this drive.
3431:22596+13	B475  3A41AB  	AUTOSL1	LDA	USERNO	;move user number into fcb.
3432:22609+16	B478  2A43AB  		LHLD	PARAMS	;(* upper half of first byte *)
3433:22625+7	B47B  B6      		ORA	M
3434:22632+7	B47C  77      		MOV	M,A
3435:22639+10	B47D  C9      		RET		;and return (all done).
3436:				;
3437:				;   Function to return the current cp/m version number.
3438:				;
3439:22649+7	B47E  3E22    	GETVER	MVI	A,022h	;version 2.2
3440:22656+10	B480  C301AB  		JMP	SETSTAT
3441:				;
3442:				;   Function to reset the disk system.
3443:				;
3444:22666+10	B483  210000  	RSTDSK	LXI	H,0	;clear write protect status and log
3445:22676+16	B486  22ADB5  		SHLD	WRTPRT	;in vector.
3446:22692+16	B489  22AFB5  		SHLD	LOGIN
3447:22708+4	B48C  AF      		XRA	A	;select drive 'A'.
3448:22712+13	B48D  3242AB  		STA	ACTIVE
3449:22725+10	B490  218000  		LXI	H,TBUFF	;setup default dma address.
3450:22735+16	B493  22B1B5  		SHLD	USERDMA
3451:22751+17	B496  CDDAAD  		CALL	DEFDMA
3452:22768+10	B499  C321B4  		JMP	LOGINDRV;now log in drive 'A'.
3453:				;
3454:				;   Function to open a specified file.
3455:				;
3456:22778+17	B49C  CD72AD  	OPENFIL	CALL	CLEARS2	;clear 's2' byte.
3457:22795+17	B49F  CD51B4  		CALL	AUTOSEL	;select proper disk.
3458:22812+10	B4A2  C351B0  		JMP	OPENIT	;and open the file.
3459:				;
3460:				;   Function to close a specified file.
3461:				;
3462:22822+17	B4A5  CD51B4  	CLOSEFIL:CALL	AUTOSEL	;select proper disk.
3463:22839+10	B4A8  C3A2B0  		JMP	CLOSEIT	;and close the file.
3464:				;
3465:				;   Function to return the first occurence of a specified file
3466:				; name. If the first byte of the fcb is '?' then the name will
3467:				; not be checked (get the first entry no matter what).
3468:				;
3469:22849+7	B4AB  0E00    	GETFST	MVI	C,0	;prepare for special search.
3470:22856+4	B4AD  EB      		XCHG
3471:22860+7	B4AE  7E      		MOV	A,M	;is first byte a '?'?
3472:22867+7	B4AF  FE3F    		CPI	'?'
3473:22874+10	B4B1  CAC2B4  		JZ	GETFST1	;yes, just get very first entry (zero length match).
3474:22884+17	B4B4  CDA6AC  		CALL	SETEXT	;get the extension byte from fcb.
3475:22901+7	B4B7  7E      		MOV	A,M	;is it '?'? if yes, then we want
3476:22908+7	B4B8  FE3F    		CPI	'?'	;an entry with a specific 's2' byte.
3477:22915+11+6	B4BA  C472AD  		CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
3478:22926+17	B4BD  CD51B4  		CALL	AUTOSEL	;select proper drive.
3479:22943+7	B4C0  0E0F    		MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
3480:22950+17	B4C2  CD18AF  	GETFST1	CALL	FINDFST	;find an entry and then move it into
3481:22967+10	B4C5  C3E9AD  		JMP	MOVEDIR	;the users dma space.
3482:				;
3483:				;   Function to return the next occurence of a file name.
3484:				;
3485:22977+16	B4C8  2AD9B5  	GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
3486:22993+16	B4CB  2243AB  		SHLD	PARAMS	;other dbos calls are allowed.
3487:23009+17	B4CE  CD51B4  		CALL	AUTOSEL	;no error will be returned, but the
3488:23026+17	B4D1  CD2DAF  		CALL	FINDNXT	;results will be wrong.
3489:23043+10	B4D4  C3E9AD  		JMP	MOVEDIR
3490:				;
3491:				;   Function to delete a file by name.
3492:				;
3493:23053+17	B4D7  CD51B4  	DELFILE	CALL	AUTOSEL	;select proper drive.
3494:23070+17	B4DA  CD9CAF  		CALL	ERAFILE	;erase the file.
3495:23087+10	B4DD  C301AF  		JMP	STSTATUS;set status and return.
3496:				;
3497:				;   Function to execute a sequential read of the specified
3498:				; record number.
3499:				;
3500:23097+17	B4E0  CD51B4  	READSEQ	CALL	AUTOSEL	;select proper drive then read.
3501:23114+10	B4E3  C3BCB1  		JMP	RDSEQ
3502:				;
3503:				;   Function to write the net sequential record.
3504:				;
3505:23124+17	B4E6  CD51B4  	WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
3506:23141+10	B4E9  C3FEB1  		JMP	WTSEQ
3507:				;
3508:				;   Create a file function.
3509:				;
3510:23151+17	B4EC  CD72AD  	FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
3511:23168+17	B4EF  CD51B4  		CALL	AUTOSEL	;select proper drive and get the next
3512:23185+10	B4F2  C324B1  		JMP	GETEMPTY;empty directory space.
3513:				;
3514:				;   Function to rename a file.
3515:				;
3516:23195+17	B4F5  CD51B4  	RENFILE	CALL	AUTOSEL	;select proper drive and then switch
3517:23212+17	B4F8  CD16B0  		CALL	CHGNAMES;file names.
3518:23229+10	B4FB  C301AF  		JMP	STSTATUS
3519:				;
3520:				;   Function to return the login vector.
3521:				;
3522:23239+16	B4FE  2AAFB5  	GETLOG	LHLD	LOGIN
3523:23255+10	B501  C329B5  		JMP	GETPRM1
3524:				;
3525:				;   Function to return the current disk assignment.
3526:				;
3527:23265+13	B504  3A42AB  	GETCRNT	LDA	ACTIVE
3528:23278+10	B507  C301AB  		JMP	SETSTAT
3529:				;
3530:				;   Function to set the dma address.
3531:				;
3532:23288+4	B50A  EB      	PUTDMA	XCHG
3533:23292+16	B50B  22B1B5  		SHLD	USERDMA	;save in our space and then get to
3534:23308+10	B50E  C3DAAD  		JMP	DEFDMA	;the bios with this also.
3535:				;
3536:				;   Function to return the allocation vector.
3537:				;
3538:23318+16	B511  2ABFB5  	GETALOC	LHLD	ALOCVECT
3539:23334+10	B514  C329B5  		JMP	GETPRM1
3540:				;
3541:				;   Function to return the read-only status vector.
3542:				;
3543:23344+16	B517  2AADB5  	GETROV	LHLD	WRTPRT
3544:23360+10	B51A  C329B5  		JMP	GETPRM1
3545:				;
3546:				;   Function to set the file attributes (read-only, system).
3547:				;
3548:23370+17	B51D  CD51B4  	SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
3549:23387+17	B520  CD3BB0  		CALL	SAVEATTR
3550:23404+10	B523  C301AF  		JMP	STSTATUS
3551:				;
3552:				;   Function to return the address of the disk parameter block
3553:				; for the current drive.
3554:				;
3555:23414+16	B526  2ABBB5  	GETPARM	LHLD	DISKPB
3556:23430+16	B529  2245AB  	GETPRM1	SHLD	STATUS
3557:23446+10	B52C  C9      		RET
3558:				;
3559:				;   Function to get or set the user number. If (E) was (FF)
3560:				; then this is a request to return the current user number.
3561:				; Else set the user number from (E).
3562:				;
3563:23456+13	B52D  3AD6B5  	GETUSER	LDA	EPARAM	;get parameter.
3564:23469+7	B530  FEFF    		CPI	0FFH	;get user number?
3565:23476+10	B532  C23BB5  		JNZ	SETUSER
3566:23486+13	B535  3A41AB  		LDA	USERNO	;yes, just do it.
3567:23499+10	B538  C301AB  		JMP	SETSTAT
3568:23509+7	B53B  E61F    	SETUSER	ANI	1FH	;no, we should set it instead. keep low
3569:23516+13	B53D  3241AB  		STA	USERNO	;bits (0-4) only.
3570:23529+10	B540  C9      		RET
3571:				;
3572:				;   Function to read a random record from a file.
3573:				;
3574:23539+17	B541  CD51B4  	RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
3575:23556+10	B544  C393B3  		JMP	READRAN
3576:				;
3577:				;   Function to compute the file size for random files.
3578:				;
3579:23566+17	B547  CD51B4  	WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
3580:23583+10	B54A  C39CB3  		JMP	WRITERAN
3581:				;
3582:				;   Function to compute the size of a random file.
3583:				;
3584:23593+17	B54D  CD51B4  	FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
3585:23610+10	B550  C3D2B3  		JMP	RANSIZE
3586:				;
3587:				;   Function #37. This allows a program to log off any drives.
3588:				; On entry, set (DE) to contain a word with bits set for those
3589:				; drives that are to be logged off. The log-in vector and the
3590:				; write protect vector will be updated. This must be a M/PM
3591:				; special function.
3592:				;
3593:23620+16	B553  2A43AB  	LOGOFF	LHLD	PARAMS	;get drives to log off.
3594:23636+5	B556  7D      		MOV	A,L	;for each bit that is set, we want
3595:23641+4	B557  2F      		CMA		;to clear that bit in (LOGIN)
3596:23645+5	B558  5F      		MOV	E,A	;and (WRTPRT).
3597:23650+5	B559  7C      		MOV	A,H
3598:23655+4	B55A  2F      		CMA
3599:23659+16	B55B  2AAFB5  		LHLD	LOGIN	;reset the login vector.
3600:23675+4	B55E  A4      		ANA	H
3601:23679+5	B55F  57      		MOV	D,A
3602:23684+5	B560  7D      		MOV	A,L
3603:23689+4	B561  A3      		ANA	E
3604:23693+5	B562  5F      		MOV	E,A
3605:23698+16	B563  2AADB5  		LHLD	WRTPRT
3606:23714+4	B566  EB      		XCHG
3607:23718+16	B567  22AFB5  		SHLD	LOGIN	;and save.
3608:23734+5	B56A  7D      		MOV	A,L	;now do the write protect vector.
3609:23739+4	B56B  A3      		ANA	E
3610:23743+5	B56C  6F      		MOV	L,A
3611:23748+5	B56D  7C      		MOV	A,H
3612:23753+4	B56E  A2      		ANA	D
3613:23757+5	B56F  67      		MOV	H,A
3614:23762+16	B570  22ADB5  		SHLD	WRTPRT	;and save. all done.
3615:23778+10	B573  C9      		RET
3616:				;
3617:				;   Get here to return to the user.
3618:				;
3619:23788+13	B574  3ADEB5  	GOBACK	LDA	AUTO	;was auto select activated?
3620:23801+4	B577  B7      		ORA	A
3621:23805+10	B578  CA91B5  		JZ	GOBACK1
3622:23815+16	B57B  2A43AB  		LHLD	PARAMS	;yes, but was a change made?
3623:23831+10	B57E  3600    		MVI	M,0	;(* reset first byte of fcb *)
3624:23841+13	B580  3AE0B5  		LDA	AUTOFLAG
3625:23854+4	B583  B7      		ORA	A
3626:23858+10	B584  CA91B5  		JZ	GOBACK1
3627:23868+7	B587  77      		MOV	M,A	;yes, reset first byte properly.
3628:23875+13	B588  3ADFB5  		LDA	OLDDRV	;and get the old drive and select it.
3629:23888+13	B58B  32D6B5  		STA	EPARAM
3630:23901+17	B58E  CD45B4  		CALL	SETDSK
3631:23918+16	B591  2A0FAB  	GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
3632:23934+5	B594  F9      		SPHL
3633:23939+16	B595  2A45AB  		LHLD	STATUS	;get return status.
3634:23955+5	B598  7D      		MOV	A,L	;force version 1.4 compatability.
3635:23960+5	B599  44      		MOV	B,H
3636:23965+10	B59A  C9      		RET		;and go back to user.
3637:				;
3638:				;   Function #40. This is a special entry to do random i/o.
3639:				; For the case where we are writing to unused disk space, this
3640:				; space will be zeroed out first. This must be a M/PM special
3641:				; purpose function, because why would any normal program even
3642:				; care about the previous contents of a sector about to be
3643:				; written over.
3644:				;
3645:23975+17	B59B  CD51B4  	WTSPECL	CALL	AUTOSEL	;select proper drive.
3646:23992+7	B59E  3E02    		MVI	A,2	;use special write mode.
3647:23999+13	B5A0  32D5B5  		STA	MODE
3648:24012+7	B5A3  0E00    		MVI	C,0	;set write indicator.
3649:24019+17	B5A5  CD07B3  		CALL	POSITN1	;position the file.
3650:24036+11+6	B5A8  CC03B2  		CZ	WTSEQ1	;and write (if no errors).
3651:24047+10	B5AB  C9      		RET
3652:				;
3653:				;**************************************************************
3654:				;*
3655:				;*     BDOS data storage pool.
3656:				;*
3657:				;**************************************************************
3658:				;
3659:     -	B5AC  E5      	EMPTYFCB:DB	0E5H	;empty directory segment indicator.
3660:     -	B5AD  0000    	WRTPRT	DW	0	;write protect status for all 16 drives.
3661:     -	B5AF  0000    	LOGIN	DW	0	;drive active word (1 bit per drive).
3662:     -	B5B1  8000    	USERDMA	DW	080H	;user's dma address (defaults to 80h).
3663:				;
3664:				;   Scratch areas from parameter block.
3665:				;
3666:     -	B5B3  0000    	SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
3667:     -	B5B5  0000    	SCRATCH2:DW	0	;last selected track number.
3668:     -	B5B7  0000    	SCRATCH3:DW	0	;last selected sector number.
3669:				;
3670:				;   Disk storage areas from parameter block.
3671:				;
3672:     -	B5B9  0000    	DIRBUF	DW	0	;address of directory buffer to use.
3673:     -	B5BB  0000    	DISKPB	DW	0	;contains address of disk parameter block.
3674:     -	B5BD  0000    	CHKVECT	DW	0	;address of check vector.
3675:     -	B5BF  0000    	ALOCVECT:DW	0	;address of allocation vector (bit map).
3676:				;
3677:				;   Parameter block returned from the bios.
3678:				;
3679:     -	B5C1  0000    	SECTORS	DW	0	;sectors per track from bios.
3680:     -	B5C3  00      	BLKSHFT	DB	0	;block shift.
3681:     -	B5C4  00      	BLKMASK	DB	0	;block mask.
3682:     -	B5C5  00      	EXTMASK	DB	0	;extent mask.
3683:     -	B5C6  0000    	DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
3684:     -	B5C8  0000    	DIRSIZE	DW	0	;directory size.
3685:     -	B5CA  0000    	ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
3686:     -	B5CC  0000    	ALLOC1	DW	0
3687:     -	B5CE  0000    	OFFSET	DW	0	;first usable track number.
3688:     -	B5D0  0000    	XLATE	DW	0	;sector translation table address.
3689:				;
3690:				;
3691:     -	B5D2  00      	CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
3692:     -	B5D3  00      	RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
3693:     -	B5D4  00      	FNDSTAT	DB	0	;filename found status (0=found first entry).
3694:     -	B5D5  00      	MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
3695:     -	B5D6  00      	EPARAM	DB	0	;storage for register (E) on entry to bdos.
3696:     -	B5D7  00      	RELBLOCK:DB	0	;relative position within fcb of block number written.
3697:     -	B5D8  00      	COUNTER	DB	0	;byte counter for directory name searches.
3698:     -	B5D9  00000000	SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
3699:     -	B5DD  00      	BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
3700:     -	B5DE  00      	AUTO	DB	0	;if non-zero, then auto select activated.
3701:     -	B5DF  00      	OLDDRV	DB	0	;on auto select, storage for previous drive.
3702:     -	B5E0  00      	AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
3703:     -	B5E1  00      	SAVNXT	DB	0	;storage for next record number to access.
3704:     -	B5E2  00      	SAVEXT	DB	0	;storage for extent number of file.
3705:     -	B5E3  0000    	SAVNREC	DW	0	;storage for number of records in file.
3706:     -	B5E5  0000    	BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
3707:     -	B5E7  0000    	LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
3708:     -	B5E9  00      	FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
3709:     -	B5EA  0000    	FILEPOS	DW	0	;files position within directory (0 to max entries -1).
3710:				;
3711:				;   Disk directory buffer checksum bytes. One for each of the
3712:				; 16 possible drives.
3713:				;
3714:     -	B5EC  00000000	CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
3715:				;
3716:				;   Extra space ?
3717:				;
3718:     -	B5FC  00000000		DB	0,0,0,0
3719:				;
3720:				;**************************************************************
3721:				;*
3722:				;*        B I O S   J U M P   T A B L E
3723:				;*
3724:				;**************************************************************
3725:				;
3726:     -	B600          	BOOT	DS	3	;NOTE WE USE FAKE DESTINATIONS
3727:     -	B603          	WBOOT	DS	3
3728:     -	B606          	CONST	DS	3
3729:     -	B609          	CONIN	DS	3
3730:     -	B60C          	CONOUT	DS	3
3731:     -	B60F          	LIST:	DS	3
3732:     -	B612          	PUNCH	DS	3
3733:     -	B615          	READER	DS	3
3734:     -	B618          	HOME	DS	3
3735:     -	B61B          	SELDSK	DS	3
3736:     -	B61E          	SETTRK	DS	3
3737:     -	B621          	SETSEC	DS	3
3738:     -	B624          	SETDMA	DS	3
3739:     -	B627          	READ	DS	3
3740:     -	B62A          	WRITE	DS	3
3741:     -	B62D          	PRSTAT	DS	3
3742:     -	B630          	SECTRN	DS	3
3743:				;
3744:				;*
3745:				;******************   E N D   O F   C P / M   *****************
3746:				;*
3747:				
3748:				



Statistics:

     4	passes
     0	jr promotions
   500	symbols
  5632	bytes



Symbol Table:

ACTIVE          AB42      43842
ADDA2HL         AD64      44388
ADDHL           A259      41561
ALLOC0          B5CA      46538
ALLOC1          B5CC      46540
ALOCVECT        B5BF      46527
AUTO            B5DE      46558
AUTOFLAG        B5E0      46560
AUTOSEL         B451      46161
AUTOSL1         B475      46197
BACKUP          A9A4      43428
BACKUP1         A9AC      43436
BADLOAD         A77A      42874
BADSCTR         A809      43017
BADSEC          A8CA      43210
BADSEL          A8D5      43221
BADSLCT         A80B      43019
BATCH           A7AB      42923
BATCHFCB        A7AC      42924
BDOSDRV         A8C6      43206
BDOSERR         A8BA      43194
BIGDISK         B5DD      46557
BITMAP          AEA3      44707
BITMAP1         AEB1      44721
BITMAP2         AED2      44754
BITMAP3         AEF6      44790
BLKMASK         B5C4      46532
BLKNMBR         B5E5      46565
BLKSHFT         B5C3      46531
BOOT            B600      46592
BS             =08        8
CBASE           A000      40960
CCPSTACK       =A7AB      42923
CDRIVE          A7EF      42991
CHARBUF         AB0E      43790
CHECK           A230      41520
CHECKDIR        AD9E      44446
CHECKSUM        ACF7      44279
CHGDRV          A7F0      42992
CHGNAM1         B027      45095
CHGNAMES        B016      45078
CHKBLK          AC84      44164
CHKCHAR         A914      43284
CHKCON          A1C2      41410
CHKDIR1         ADC4      44484
CHKNMBR         AD8C      44428
CHKROFL         AD44      44356
CHKSUM1         ACFD      44285
CHKVECT         B5BD      46525
CHKWPRT         AD54      44372
CKBITMAP        AE35      44597
CKBMAP1         AE56      44630
CKCON1          A942      43330
CKCON2          A945      43333
CKCONSOL        A923      43299
CKFILPOS        ADF5      44533
CKROF1          AD47      44359
CKSUMTBL        B5EC      46572
CLEARBUF        A358      41816
CLEARS2         AD72      44402
CLOSE           A0DA      41178
CLOSEFIL        B4A5      46245
CLOSEFLG        B5D2      46546
CLOSEIT         B0A2      45218
CLOSEIT1        B0CD      45261
CLOSEIT2        B0DB      45275
CLOSEIT3        B0E1      45281
CLOSEIT4        B0E8      45288
CLOSEIT5        B0FD      45309
CLOSEIT6        B117      45335
CLOSEIT7        B11F      45343
CMDADR          A3C1      41921
CMDTBL          A310      41744
CMMND1          A382      41858
CMMND2          A398      41880
CNTRLC         =03        3
CNTRLE         =05        5
CNTRLP         =10        16
CNTRLR         =12        18
CNTRLS         =13        19
CNTRLU         =15        21
CNTRLX         =18        24
CNTRLZ         =1A        26
COMBLK          AC77      44151
COMFILE         A783      42883
COMMAND         A35C      41820
COMPRAND        B3A5      45989
CONIN           B609      46601
CONOUT          B60C      46604
CONST           B606      46598
CONVERT         A260      41568
CONVFST         A25E      41566
CONVRT1         A289      41609
CONVRT2         A290      41616
CONVRT3         A296      41622
CONVRT4         A298      41624
CONVRT5         A2A9      41641
CONVRT6         A2AB      41643
CONVRT7         A2AF      41647
CONVRT8         A2B9      41657
COUNTER         B5D8      46552
CR             =0D        13
CREATE          A109      41225
CRLF            A098      41112
CURPOS          AB0C      43788
DE2HL           AB4F      43855
DE2HL1          AB50      43856
DECODE          A3F8      41976
DECODE1         A408      41992
DECODE2         A42A      42026
DECODE3         A433      42035
DECODE4         A43A      42042
DEFDMA          ADDA      44506
DEL            =7F        127
DELBATCH        A1DD      41437
DELETE          A0EF      41199
DELFILE         B4D7      46295
DIRBUF          B5B9      46521
DIRC1           AAE0      43744
DIRCIO          AAD4      43732
DIRDMA          ADE0      44512
DIRDMA1         ADE3      44515
DIRECT          A477      42103
DIRECT1         A488      42120
DIRECT2         A48F      42127
DIRECT3         A498      42136
DIRECT4         A4CC      42188
DIRECT5         A4D4      42196
DIRECT6         A4D9      42201
DIRECT7         A50E      42254
DIRECT8         A50F      42255
DIRECT9         A51B      42267
DIRREAD         ADD4      44500
DIRSIZE         B5C8      46536
DIRWRITE        ADC6      44486
DISKPB          B5BB      46523
DISKRO          A8E1      43233
DMASET          A1D8      41432
DOREAD          ABB2      43954
DOWRITE         ABB8      43960
DRECT63         A4F7      42231
DRECT65         A4F9      42233
DSELECT         A454      42068
DSKSEL          A0BD      41149
DSKSIZE         B5C6      46534
EMPTYFCB        B5AC      46508
ENTRY          =05        5
ENTRY1          A0C3      41155
ENTRY2          A0F4      41204
EPARAM          B5D6      46550
ERAFIL1         AFA4      44964
ERAFILE         AF9C      44956
ERASE           A51F      42271
ERASE1          A542      42306
ERROR1          A899      43161
ERROR2          A8A5      43173
ERROR3          A8AB      43179
ERROR4          A8B1      43185
ERROR5          A8B4      43188
EXISTS          A682      42626
EXTBLK          AC5E      44126
EXTBLK1         AC71      44145
EXTMASK         B5C5      46533
EXTRACT         A44B      42059
FBASE           A806      43014
FBASE1          A811      43025
FCB             A7CD      42957
FCB2HL          AD5E      44382
FCBPOS          B5E9      46569
FCBSET          AFFD      45053
FCREATE         B4EC      46316
FF             =0C        12
FILEPOS         B5EA      46570
FILERO          A8DC      43228
FILESIZE        B54D      46413
FINDFST         AF18      44824
FINDNXT         AF2D      44845
FNDNXT1         AF4A      44874
FNDNXT2         AF53      44883
FNDNXT3         AF73      44915
FNDNXT4         AF7C      44924
FNDNXT5         AF83      44931
FNDNXT6         AF94      44948
FNDSPA1         AFC0      44992
FNDSPA2         AFD1      45009
FNDSPA3         AFEC      45036
FNDSPA4         AFF4      45044
FNDSPACE        AFBE      44990
FNDSTAT         B5D4      46548
FUNCTNS         A847      43079
GETALOC         B511      46353
GETBACK         A786      42886
GETBACK1        A789      42889
GETBLK1         AC45      44101
GETBLK2         AC53      44115
GETBLK3         AC5C      44124
GETBLOCK        AC3E      44094
GETCHAR         A8FB      43259
GETCON          AAC8      43720
GETCRNT         B504      46340
GETCSTS         AAFE      43774
GETDSK          A1D0      41424
GETECHO         A906      43270
GETEMPTY        B124      45348
GETEXT          A2C0      41664
GETEXT1         A2C8      41672
GETEXT2         A2D9      41689
GETEXT3         A2DB      41691
GETEXT4         A2DF      41695
GETEXT5         A2E9      41705
GETEXT6         A2F0      41712
GETEXT7         A2F2      41714
GETEXT8         A301      41729
GETEXT9         A309      41737
GETFST          B4AB      46251
GETFST1         B4C2      46274
GETINP          A139      41273
GETINP1         A196      41366
GETINP2         A1A7      41383
GETINP3         A1AB      41387
GETINP4         A1BA      41402
GETIOB          AAED      43757
GETLOG          B4FE      46334
GETMT1          B146      45382
GETNEXT         B15A      45402
GETNXT          B4C8      46280
GETPARM         B526      46374
GETPRM1         B529      46377
GETRDR          AACE      43726
GETROV          B517      46359
GETS2           AD69      44393
GETSETUC        A115      41237
GETUSER         B52D      46381
GETUSR          A113      41235
GETVER          B47E      46206
GETWPRT         AD1E      44318
GOBACK          B574      46452
GOBACK1         B591      46481
GTNEXT1         B183      45443
GTNEXT2         B18E      45454
GTNEXT3         B1AC      45484
GTNEXT4         B1AF      45487
GTNEXT5         B1B6      45494
HALT            A3CF      41935
HL2DE           A442      42050
HOME            B618      46616
HOMEDRV         ABA1      43937
INBUFF          A006      40966
INPOINT         A088      41096
IOBYTE         =03        3
IOERR1          AB05      43781
IORET           ABBB      43963
JUMPHL          AB4A      43850
LF             =0A        10
LIST            B60F      46607
LOGICAL         AC8A      44170
LOGICL1         AC90      44176
LOGIN           B5AF      46511
LOGINDRV        B421      46113
LOGOFF          B553      46419
LOGSECT         B5E7      46567
MEM            =2F        47
MODE            B5D5      46549
MOREFLS         AD7F      44415
MOVE3           A440      42048
MOVECD          A129      41257
MOVEDIR         ADE9      44521
MOVEWORD        B094      45204
NAMEPNT         A08A      41098
NBYTES          A7F1      42993
NEWLINE         A9B1      43441
NEWLN1          A9B9      43449
NFUNCTS        =29        41
NOFILE          A3F0      41968
NONBLANK        A24F      41551
NONE            A3EA      41962
NOSPACE         A607      42503
NUMCMDS        =06        6
NXENT1          AE19      44569
NXENT2          AE20      44576
NXENTRY         AE05      44549
OFFSET          B5CE      46542
OLDDRV          B5DF      46559
OPEN            A0CB      41163
OPENFCB         A0D0      41168
OPENFIL         B49C      46236
OPENIT          B051      45137
OPENIT1         B05A      45146
OPENIT2         B08B      45195
OUTCHAR         A948      43336
OUTCHR1         A962      43362
OUTCHR2         A979      43385
OUTCON          A990      43408
OUTCON1         A996      43414
OUTCRLF         A9C9      43465
OUTFLAG         AB0A      43786
PARAMS          AB43      43843
PATTRN1         A328      41768
PATTRN2         A800      43008
PLINE           A0A7      41127
PLINE2          A0AC      41132
POSITION        B303      45827
POSITN1         B307      45831
POSITN2         B347      45895
POSITN3         B37F      45951
POSITN4         B384      45956
POSITN5         B38B      45963
PRINT           A08C      41100
PRINTB          A092      41106
PRSTAT          B62D      46637
PRTERR          A8E5      43237
PRTFLAG         AB0D      43789
PRTMESG         A9D3      43475
PRTSTR          AAF8      43768
PUNCH           B612      46610
PUTDMA          B50A      46346
RANSIZ1         B3E4      46052
RANSIZ2         B406      46086
RANSIZ3         B40C      46092
RANSIZE         B3D2      46034
RDBUF1          A9EF      43503
RDBUF10         AA70      43632
RDBUF11         AA78      43640
RDBUF12         AA8A      43658
RDBUF13         AA99      43673
RDBUF14         AAA6      43686
RDBUF15         AAA9      43689
RDBUF16         AABD      43709
RDBUF17         AAC1      43713
RDBUF2          A9F1      43505
RDBUF3          AA16      43542
RDBUF4          AA26      43558
RDBUF5          AA37      43575
RDBUF6          AA48      43592
RDBUF7          AA4E      43598
RDBUF8          AA5F      43615
RDBUF9          AA6B      43627
RDBUFF          A9E1      43489
RDERR           A3DF      41951
RDERROR         A3D9      41945
RDRANDOM        B541      46401
RDREC           A0F9      41209
RDSEQ           B1BC      45500
RDSEQ1          B1C1      45505
RDSEQ2          B1E6      45542
RDSEQ3          B1FB      45563
RDWRTFLG        B5D3      46547
READ            B627      46631
READER          B615      46613
READFCB         A0FE      41214
READRAN         B393      45971
READSEQ         B4E0      46304
RELBLOCK        B5D7      46551
RENAM           A10E      41230
RENAME          A610      42512
RENAME1         A63F      42559
RENAME2         A659      42585
RENAME3         A65E      42590
RENAME4         A66D      42605
RENAME5         A673      42611
RENAME6         A679      42617
RENFILE         B4F5      46325
RESDSK          A0B8      41144
RESETDR         A466      42086
RODISK          A80D      43021
ROFILE          A80F      43023
RSTDSK          B483      46211
RTN             AB04      43780
RTNCODE         A7EE      42990
SAMEXT          AF07      44807
SAVATR1         B040      45120
SAVE            A5AD      42413
SAVE1           A5D4      42452
SAVE2           A5F1      42481
SAVE3           A5FB      42491
SAVE4           A601      42497
SAVEATTR        B03B      45115
SAVEFCB         B5D9      46553
SAVEXT          B5E2      46562
SAVNREC         B5E3      46563
SAVNXT          B5E1      46561
SCRATCH1        B5B3      46515
SCRATCH2        B5B5      46517
SCRATCH3        B5B7      46519
SEARCH          A32E      41774
SEARCH1         A333      41779
SEARCH2         A33C      41788
SEARCH3         A34F      41807
SEARCH4         A354      41812
SECTORS         B5C1      46529
SECTRN          B630      46640
SELDSK          B61B      46619
SELECT          AB59      43865
SELECT1         AB9D      43933
SETATTR         B51D      46365
SETBIT          AD0B      44299
SETCDRV         A11A      41242
SETDIR          AD9C      44444
SETDMA          B624      46628
SETDSK          B445      46149
SETEXT          ACA6      44198
SETFILE         AE6B      44651
SETFL1          AE75      44661
SETFL2          AE88      44680
SETFL3          AE8E      44686
SETFL4          AE9D      44701
SETHLDE         ACAE      44206
SETIOB          AAF3      43763
SETNREC         ACD2      44242
SETRAN          B40E      46094
SETS2B7         AD78      44408
SETSEC          B621      46625
SETSTAT         AB01      43777
SETTRK          B61E      46622
SETUSER         B53B      46395
SHIFTL          AD04      44292
SHIFTL1         AD05      44293
SHIFTR          ACEA      44266
SHIFTR1         ACEB      44267
SHOWIT          A97F      43391
SLCTERR         AB47      43847
SPACE           A0A2      41122
SRCHFCB         A0E9      41193
SRCHFST         A0DF      41183
SRCHNXT         A0E4      41188
STARTING        AB0B      43787
STATUS          AB45      43845
STBITMAP        AE5C      44636
STBMAP1         AE64      44644
STDDMA          A1D5      41429
STFILPOS        ADFE      44542
STKAREA        =AB41      43841
STNREC1         ACDE      44254
STRDATA         ACBB      44219
STSTATUS        AF01      44801
SUBHL           AD95      44437
SYNERR          A209      41481
SYNERR1         A20F      41487
SYNERR2         A222      41506
TAB            =09        9
TBASE          = 100      256
TBUFF          =80        128
TDRIVE         =04        4
TFCB           =5C        92
TRKSEC          ABC3      43971
TRKSEC1         ABD1      43985
TRKSEC2         ABE4      44004
TRKSEC3         ABFA      44026
TRKSEC4         AC0F      44047
TYPE            A55D      42333
TYPE1           A574      42356
TYPE2           A577      42359
TYPE3           A587      42375
TYPE4           A5A0      42400
TYPE5           A5A7      42407
UNKNOWN         A6A5      42661
UNKWN0          A771      42865
UNKWN1          A6C4      42692
UNKWN2          A6CD      42701
UNKWN3          A6E1      42721
UNKWN4          A701      42753
UNKWN5          A730      42800
UNKWN6          A73E      42814
UNKWN7          A743      42819
UNKWN8          A74F      42831
UNKWN9          A76B      42859
UPDATE          B001      45057
UPDATE1         B010      45072
UPPER           A130      41264
USER            A68E      42638
USERDMA         B5B1      46513
USERNO          AB41      43841
USRSTACK        AB0F      43791
VERIFY          A1F5      41461
VERIFY1         A1FD      41469
WBOOT           B603      46595
WRITE           B62A      46634
WRITERAN        B39C      45980
WRTPRT          B5AD      46509
WRTPRTD         AD2C      44332
WRTREC          A104      41220
WRTSEQ          B4E6      46310
WTRANDOM        B547      46407
WTSEQ           B1FE      45566
WTSEQ1          B203      45571
WTSEQ10         B2D2      45778
WTSEQ11         B2FE      45822
WTSEQ12         B300      45824
WTSEQ2          B23B      45627
WTSEQ3          B248      45640
WTSEQ4          B264      45668
WTSEQ5          B26C      45676
WTSEQ6          B26E      45678
WTSEQ7          B28C      45708
WTSEQ8          B29A      45722
WTSEQ9          B2BB      45755
WTSEQ99         B2DF      45791
WTSPECL         B59B      46491
XLATE           B5D0      46544
YESNO           A552      42322
